<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++基础</title>
      <link href="//blogs/c++%E5%9F%BA%E7%A1%80.html"/>
      <url>//blogs/c++%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-c-初识"><a href="#1-c-初识" class="headerlink" title="1 c++初识"></a>1 c++初识</h3><h4 id="1-1-第一个c-程序"><a href="#1-1-第一个c-程序" class="headerlink" title="1.1  第一个c++ 程序"></a>1.1  第一个c++ 程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 使用命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello c++&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h4><p>作用：在代码中加一些说明和解释，方便阅读代码<br>两种格式</p><ol><li>单行注释：<code>//描述休息</code><ul><li>通常放在一行的代码的上方或者一条语句的末尾，对改行代码说明</li></ul></li><li>多行注释：<code>/*描述休息*/</code><ul><li>通常放在一段代码的上方，对该段代码做整体说明</li></ul></li></ol><h4 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h4><p>作用：给一段指定的内存空间起名，方便操作这段内存<br>语法：数据类型 变量名 &#x3D; 初始值</p><h4 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h4><p>作用： 用于记录程序中不可更改的数据<br>两种方式</p><ol><li>#define 宏常量: <code>define 常量名 常量值</code><ul><li>通常在文件上方定义，便是一个常量</li></ul></li><li>const修饰的变量 <code>const 数据类型 常量名 = 常量值</code><ul><li>通常在变量定义前加关键字const，修饰该变量为常量，不可修改</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Week 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一周有&quot;</span> &lt;&lt; Week &lt;&lt; <span class="string">&quot;天&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Week = <span class="number">7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;一周有&quot;</span> &lt;&lt; Week &lt;&lt; <span class="string">&quot;天&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-5-标识符命名规则"><a href="#1-5-标识符命名规则" class="headerlink" title="1.5 标识符命名规则"></a>1.5 标识符命名规则</h4><p>作用：c++规定给标志符（变量、常量）命名时的规则</p><ul><li>标识符不能是关键字</li><li>标志都只能由字母、数字、下划线组成</li><li>第一个字符必须是字母或者下划线</li><li>标识符字母中区分大小写</li></ul><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h3><p>c++ 规定在创建一个变量或者常量时，必须指定出相应的数据类型。</p><h4 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h4><p>作用：整型变量表示是整数类型的数据<br>c++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>。</p><p>在 C++ 里，不同的整型数据类型有着不同的取值范围。以下表格呈现了在常见的 32 位和 64 位系统中，各整型类型的取值范围：</p><table><thead><tr><th>数据类型</th><th>位数</th><th>取值范围（32 位系统）</th><th>取值范围（64 位系统）</th></tr></thead><tbody><tr><td><code>char</code></td><td>8</td><td>-128 到 127</td><td>-128 到 127</td></tr><tr><td><code>unsigned char</code></td><td>8</td><td>0 到 255</td><td>0 到 255</td></tr><tr><td><code>short</code></td><td>16</td><td>-32,768 到 32,767</td><td>-32,768 到 32,767</td></tr><tr><td><code>unsigned short</code></td><td>16</td><td>0 到 65,535</td><td>0 到 65,535</td></tr><tr><td><code>int</code></td><td>32</td><td>-2,147,483,648 到 2,147,483,647</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><code>unsigned int</code></td><td>32</td><td>0 到 4,294,967,295</td><td>0 到 4,294,967,295</td></tr><tr><td><code>long</code></td><td>32</td><td>-2,147,483,648 到 2,147,483,647</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td><code>unsigned long</code></td><td>32</td><td>0 到 4,294,967,295</td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td><code>long long</code></td><td>64</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td><code>unsigned long long</code></td><td>64</td><td>0 到 18,446,744,073,709,551,615</td><td>0 到 18,446,744,073,709,551,615</td></tr></tbody></table><p>要注意的是，<code>long</code> 类型在 32 位和 64 位系统中的位数可能有差异。为了确保代码的可移植性，建议使用 <code>std::int32_t</code>、<code>std::uint32_t</code>、<code>std::int64_t</code>、<code>std::uint64_t</code> 等固定宽度的整数类型，这些类型定义于 <code>&lt;cstdint&gt;</code> 头文件中。 </p><blockquote><p>sizeof关键字<br>作用：利用sizeof关键字可以统数据类型所占的内存大小<br>语法： sizeof(数据类型 &#x2F; 变量)</p></blockquote><h4 id="2-2-浮点型"><a href="#2-2-浮点型" class="headerlink" title="2.2 浮点型"></a>2.2 浮点型</h4><p>作用：用于表示小数<br>浮点型分为两种</p><ol><li>单精度float</li><li>双精度double</li></ol><p>两者区别在于表示数字范围不同<br>在 C++ 中，浮点型数据类型主要有 <code>float</code>、<code>double</code> 和 <code>long double</code>，它们的取值范围和精度与具体的编译器和硬件平台有关，但通常遵循 IEEE 754 标准。以下是以表格形式呈现的常见取值范围信息：</p><table><thead><tr><th>数据类型</th><th>位数</th><th>有效数字（十进制）</th><th>取值范围（近似）</th></tr></thead><tbody><tr><td><code>float</code></td><td>32</td><td>6 - 7 位</td><td>±1.18×10⁻³⁸ 到 ±3.40×10³⁸</td></tr><tr><td><code>double</code></td><td>64</td><td>15 - 16 位</td><td>±2.23×10⁻³⁰⁸ 到 ±1.80×10³⁰⁸</td></tr><tr><td><code>long double</code></td><td>通常 80 位或更多</td><td>18 - 19 位（80 位时）</td><td>不同编译器和平台有所差异，一般比 <code>double</code> 范围更大，如 GCC 下约为 ±3.37×10⁻⁴⁹³² 到 ±1.19×10⁴⁹³²</td></tr></tbody></table><p>在实际使用中，你可以通过 <code>&lt;limits&gt;</code> 头文件中的 <code>std::numeric_limits</code> 来获取更精确的取值范围信息，以下是示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float 最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">min</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;float 最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">max</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double 最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double 最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double 最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">min</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;long double 最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">max</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码利用 <code>std::numeric_limits</code> 来输出不同浮点型数据类型的最小值和最大值。 </p><h4 id="2-3-字符型"><a href="#2-3-字符型" class="headerlink" title="2.3 字符型"></a>2.3 字符型</h4><p>作用：字符型变量用于显示单个字符</p><p>语法： <code>char ch = &#39;a&#39;</code></p><ul><li>字符值用单引号</li><li>c&#x2F;c++中字符型变量只占一个字节</li><li>字符型变量并不是把字符本身放在内存中存储，而是将对应的ASCll编码放入到存储单元</li></ul><h4 id="2-4-转义字符"><a href="#2-4-转义字符" class="headerlink" title="2.4 转义字符"></a>2.4 转义字符</h4><p>作用：用于表示一些不能显示出来的ASCll字符<br>常用的有 <code>\n \\ \t</code></p><h4 id="2-5-字符串类型"><a href="#2-5-字符串类型" class="headerlink" title="2.5 字符串类型"></a>2.5 字符串类型</h4><p>作用：用于表示一串字符<br>两种风格</p><ol><li>c风格字符串：<code>char 变量名[] = &quot;字符串值&quot;</code></li><li>c++风格字符串：<code>string 变量名 = &quot;字符串值&quot;</code><blockquote><p>c++ 风格要引入<strong>string</strong>头文件  </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//c风格</span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;c风格&quot;</span>;</span><br><span class="line">cout &lt;&lt; str  &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++风格 需要引入string头文件</span></span><br><span class="line">string str1 = <span class="string">&quot;c++风格&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-6-布尔类型"><a href="#2-6-布尔类型" class="headerlink" title="2.6 布尔类型"></a>2.6 布尔类型</h4><p>作用：布尔数据类型代表 真 或者 假 的值<br>布尔类型值只有两个  </p><ul><li>true — 真(本质为1)</li><li>false — 假(本质为0)<br>bool类型只占一个字节</li></ul><h4 id="2-7-数据的输入"><a href="#2-7-数据的输入" class="headerlink" title="2.7 数据的输入"></a>2.7 数据的输入</h4><p>作用：用于从键盘获取数据<br>关键字：cin<br>语法：<code>cin &gt;&gt; 变量</code></p><h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h3><p>作用：用于执行代码的运算</p><h4 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h4><p>在C++里，算术运算符用于执行基本的数学运算。以下是以表格形式对常用算术运算符的介绍：</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法运算符</td><td>对两个操作数进行相加</td><td><code>int a = 5 + 3;</code></td><td><code>a</code> 的值为 8</td></tr><tr><td><code>-</code></td><td>减法运算符</td><td>从第一个操作数中减去第二个操作数</td><td><code>int b = 7 - 2;</code></td><td><code>b</code> 的值为 5</td></tr><tr><td><code>*</code></td><td>乘法运算符</td><td>将两个操作数相乘</td><td><code>int c = 4 * 6;</code></td><td><code>c</code> 的值为 24</td></tr><tr><td><code>/</code></td><td>除法运算符</td><td>用第一个操作数除以第二个操作数。若操作数是整数，结果会截断小数部分</td><td><code>int d = 10 / 3;</code> <br> <code>double e = 10.0 / 3.0;</code></td><td><code>d</code> 的值为 3 <br> <code>e</code> 的值约为 3.33333</td></tr><tr><td><code>%</code></td><td>取模运算符（求余运算符）</td><td>计算两个整数相除后的余数，操作数必须为整数类型</td><td><code>int f = 10 % 3;</code></td><td><code>f</code> 的值为 1</td></tr><tr><td><code>++</code></td><td>自增运算符</td><td>使操作数的值增加 1。可分为前置自增（<code>++var</code>）和后置自增（<code>var++</code>）</td><td><code>int g = 5; &lt;br&gt; int h = ++g;</code> <br> <code>int i = 5; &lt;br&gt; int j = i++;</code></td><td><code>h</code> 的值为 6，<code>g</code> 的值为 6 <br> <code>j</code> 的值为 5，<code>i</code> 的值为 6</td></tr><tr><td><code>--</code></td><td>自减运算符</td><td>使操作数的值减少 1。可分为前置自减（<code>--var</code>）和后置自减（<code>var--</code>）</td><td><code>int k = 5; &lt;br&gt; int l = --k;</code> <br> <code>int m = 5; &lt;br&gt; int n = m--;</code></td><td><code>l</code> 的值为 4，<code>k</code> 的值为 4 <br> <code>n</code> 的值为 5，<code>m</code> 的值为 4</td></tr></tbody></table><p>以下是一个简单的 C++ 代码示例，展示了这些运算符的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;加法: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;减法: &quot;</span> &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;乘法: &quot;</span> &lt;&lt; a * b &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;除法: &quot;</span> &lt;&lt; a / b &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 取模</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;取模: &quot;</span> &lt;&lt; a % b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = a;</span><br><span class="line">    <span class="comment">// 前置自增</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前置自增: &quot;</span> &lt;&lt; ++c &lt;&lt; std::endl;</span><br><span class="line">    c = a;</span><br><span class="line">    <span class="comment">// 后置自增</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后置自增: &quot;</span> &lt;&lt; c++ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后置自增后的值: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> d = a;</span><br><span class="line">    <span class="comment">// 前置自减</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前置自减: &quot;</span> &lt;&lt; --d &lt;&lt; std::endl;</span><br><span class="line">    d = a;</span><br><span class="line">    <span class="comment">// 后置自减</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后置自减: &quot;</span> &lt;&lt; d-- &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后置自减后的值: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码对上述提到的算术运算符进行了演示，你可以运行代码来查看每个运算符的具体效果。 </p><h4 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h4><p>在 C++ 中，赋值运算符用于将一个值赋给一个变量，除了基本的 <code>=</code> 赋值运算符外，还有一些复合赋值运算符，下面以表格形式为你详细介绍：</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>等价于</th></tr></thead><tbody><tr><td><code>=</code></td><td>简单赋值运算符</td><td>将右侧操作数的值赋给左侧操作数</td><td><code>int a = 5;</code></td><td>-</td></tr><tr><td><code>+=</code></td><td>加赋值运算符</td><td>将右侧操作数的值加到左侧操作数上，并将结果赋给左侧操作数</td><td><code>int a = 3; a += 2;</code></td><td><code>a = a + 2;</code></td></tr><tr><td><code>-=</code></td><td>减赋值运算符</td><td>从左侧操作数中减去右侧操作数的值，并将结果赋给左侧操作数</td><td><code>int a = 7; a -= 4;</code></td><td><code>a = a - 4;</code></td></tr><tr><td><code>*=</code></td><td>乘赋值运算符</td><td>将左侧操作数乘以右侧操作数的值，并将结果赋给左侧操作数</td><td><code>int a = 2; a *= 3;</code></td><td><code>a = a * 3;</code></td></tr><tr><td><code>/=</code></td><td>除赋值运算符</td><td>将左侧操作数除以右侧操作数的值，并将结果赋给左侧操作数</td><td><code>int a = 10; a /= 2;</code></td><td><code>a = a / 2;</code></td></tr><tr><td><code>%=</code></td><td>取模赋值运算符</td><td>计算左侧操作数除以右侧操作数的余数，并将结果赋给左侧操作数</td><td><code>int a = 10; a %= 3;</code></td><td><code>a = a % 3;</code></td></tr><tr><td><code>&amp;=</code></td><td>按位与赋值运算符</td><td>对左侧和右侧操作数进行按位与运算，并将结果赋给左侧操作数</td><td><code>int a = 5; a &amp;= 3;</code></td><td><code>a = a &amp; 3;</code></td></tr><tr><td>&#96;</td><td>&#x3D;&#96;</td><td>按位或赋值运算符</td><td>对左侧和右侧操作数进行按位或运算，并将结果赋给左侧操作数</td><td>&#96;int a &#x3D; 5; a</td></tr><tr><td><code>^=</code></td><td>按位异或赋值运算符</td><td>对左侧和右侧操作数进行按位异或运算，并将结果赋给左侧操作数</td><td><code>int a = 5; a ^= 3;</code></td><td><code>a = a ^ 3;</code></td></tr><tr><td><code>&lt;&lt;=</code></td><td>左移赋值运算符</td><td>将左侧操作数向左移动右侧操作数指定的位数，并将结果赋给左侧操作数</td><td><code>int a = 5; a &lt;&lt;= 2;</code></td><td><code>a = a &lt;&lt; 2;</code></td></tr><tr><td><code>&gt;&gt;=</code></td><td>右移赋值运算符</td><td>将左侧操作数向右移动右侧操作数指定的位数，并将结果赋给左侧操作数</td><td><code>int a = 5; a &gt;&gt;= 2;</code></td><td><code>a = a &gt;&gt; 2;</code></td></tr></tbody></table><p>以下是一个简单的 C++ 代码示例，展示了这些赋值运算符的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 简单赋值</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;简单赋值后 b 的值: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加赋值</span></span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;加赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减赋值</span></span><br><span class="line">    a = <span class="number">7</span>;</span><br><span class="line">    a -= <span class="number">4</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;减赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乘赋值</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    a *= <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;乘赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除赋值</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    a /= <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;除赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取模赋值</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    a %= <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;取模赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位与赋值</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    a &amp;= <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按位与赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位或赋值</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    a |= <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按位或赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按位异或赋值</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    a ^= <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;按位异或赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左移赋值</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    a &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左移赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右移赋值</span></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    a &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右移赋值后 a 的值: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个代码示例展示了各种赋值运算符的使用，你可以运行代码来查看每个运算符的具体效果。 </p><h4 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h4><p>在 C++ 里，比较运算符用于比较两个值，其结果为布尔类型（<code>true</code> 或者 <code>false</code>）。以下以表格形式详细介绍常见的比较运算符：</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于运算符</td><td>检查两个操作数是否相等，若相等则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 5; int b = 5; bool result = (a == b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr><tr><td><code>!=</code></td><td>不等于运算符</td><td>检查两个操作数是否不相等，若不相等则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 5; int b = 3; bool result = (a != b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr><tr><td><code>&gt;</code></td><td>大于运算符</td><td>检查左操作数是否大于右操作数，若是则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 7; int b = 4; bool result = (a &gt; b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr><tr><td><code>&lt;</code></td><td>小于运算符</td><td>检查左操作数是否小于右操作数，若是则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 2; int b = 5; bool result = (a &lt; b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr><tr><td><code>&gt;=</code></td><td>大于等于运算符</td><td>检查左操作数是否大于或等于右操作数，若是则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 5; int b = 5; bool result = (a &gt;= b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr><tr><td><code>&lt;=</code></td><td>小于等于运算符</td><td>检查左操作数是否小于或等于右操作数，若是则返回 <code>true</code>，反之返回 <code>false</code></td><td><code>int a = 3; int b = 5; bool result = (a &lt;= b);</code></td><td><code>result</code> 的值为 <code>true</code></td></tr></tbody></table><p>以下是一个简单的 C++ 代码示例，用来展示这些比较运算符的运用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a == b: &quot;</span> &lt;&lt; (a == b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 不等于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a != b: &quot;</span> &lt;&lt; (a != b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 大于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a &gt; b: &quot;</span> &lt;&lt; (a &gt; b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 小于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a &lt; b: &quot;</span> &lt;&lt; (a &lt; b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 大于等于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a &gt;= b: &quot;</span> &lt;&lt; (a &gt;= b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 小于等于运算符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a &lt;= b: &quot;</span> &lt;&lt; (a &lt;= b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个代码中，对上述提到的比较运算符进行了演示，你可以运行代码来查看每个运算符的具体结果。注意，<code>std::cout</code> 输出布尔值时，<code>true</code> 显示为 <code>1</code>，<code>false</code> 显示为 <code>0</code>。 </p><h4 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h4><p>在 C++ 中，逻辑运算符用于布尔值操作，结果为布尔类型。以下是常见逻辑运算符介绍：</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>两操作数都为 <code>true</code> 时结果为 <code>true</code></td><td><code>true &amp;&amp; false</code></td><td><code>false</code></td></tr><tr><td><code>||</code></td><td>逻辑或</td><td>有一个操作数为 <code>true</code> 结果就为 <code>true</code></td><td><code>false || true</code></td><td><code>true</code></td></tr><tr><td><code>!</code></td><td>逻辑非</td><td>对操作数取反</td><td><code>!true</code></td><td><code>false</code></td></tr></tbody></table><p>短路求值</p><ul><li><code>&amp;&amp;</code>：当左侧操作数为 false 时，由于无论右侧操作数是什么，整个表达式结果都为 false，所以不会再计算右侧操作数。。</li><li><code>||</code>：当左侧操作数为 true 时，由于无论右侧操作数是什么，整个表达式结果都为 true，所以不会再计算右侧操作数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; (<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="literal">false</span> || <span class="literal">true</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; !<span class="literal">true</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码对逻辑运算符进行了简单测试，输出结果中 <code>1</code> 代表 <code>true</code>，<code>0</code> 代表 <code>false</code>。 </p><h3 id="4-程序流程结构"><a href="#4-程序流程结构" class="headerlink" title="4 程序流程结构"></a>4 程序流程结构</h3><p>程序的流程结构主要分为顺序结构、选择结构和循环结构。</p><h4 id="4-1-顺序结构"><a href="#4-1-顺序结构" class="headerlink" title="4.1 顺序结构"></a>4.1 顺序结构</h4><p>顺序结构是程序中最基本的结构，程序会按照语句的先后顺序依次执行，即先执行第一条语句，接着执行第二条，依此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是第一条语句。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是第二条语句。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序会先输出 “这是第一条语句。”，然后输出 “这是第二条语句。”。</p><h4 id="4-2-选择结构"><a href="#4-2-选择结构" class="headerlink" title="4.2 选择结构"></a>4.2 选择结构</h4><p>选择结构会依据条件判断的结果来决定执行哪些语句，C++ 里常见的选择结构有 if - else 语句和 switch 语句。</p><ol><li>if - else 语句<br> if - else 语句可以根据条件的真假来执行不同的代码块。它有以下几种形式：<ul><li>单分支 if 语句： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数字大于 5。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>双分支 if - else语句： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数字大于 5。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数字小于等于 5。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多分支 if - else if - else 语句： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> score = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成绩为 A。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成绩为 B。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成绩为 C。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成绩为 D。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>三目运算符<br>语法：表达式1？表达式3：表达式3<br>条件表达式：这是一个布尔表达式，会先对其进行求值。若值为 true，则整个三目表达式的值为 表达式1 的值；若值为 false，则整个三目表达式的值为 表达式2 的值。<br>表达式 1：当条件表达式为 true 时返回的值。<br>表达式 2：当条件表达式为 false 时返回的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">            <span class="comment">// 使用三目表达式判断 a 和 b 的大小</span></span><br><span class="line">            <span class="type">int</span> max = (a &gt; b) ? a : b;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;较大的数是: &quot;</span> &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ```  </span><br><span class="line"><span class="number">3.</span> <span class="keyword">switch</span> 语句</span><br><span class="line">    ```cpp</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;星期一&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;星期二&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;星期三&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;其他&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-3-循环结构"><a href="#4-3-循环结构" class="headerlink" title="4.3 循环结构"></a>4.3 循环结构</h4><p>循环结构能够让程序重复执行特定的代码块，C++ 中常见的循环结构有 for 循环、while 循环和 do - while 循环。</p><ul><li>for循环<br>for 循环适用于已知循环次数的情况。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>while 循环<br>while 循环会在条件为真时不断执行循环体。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>do - while 循环<br>do - while 循环会先执行一次循环体，然后再判断条件是否为真，若为真则继续循环。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>这些程序流程结构能够组合使用，从而实现复杂的程序逻辑。</li></ul><h4 id="4-4-跳转语句"><a href="#4-4-跳转语句" class="headerlink" title="4.4 跳转语句"></a>4.4 跳转语句</h4><p>作用：用于跳出选择结构或者循环结构</p><ul><li>break语句：<ul><li>出现在switch条件语句中 作用是种植case并跳出switch</li><li>出现在循环语句中，作用跳出当前循环</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul></li><li>continue语句<ul><li>在循环语句中，跳过<strong>本次</strong>循环中余下尚未执行的语句，继续执行下次循环</li></ul></li><li>goto语句：  <ul><li>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置。</li></ul></li></ul><p>语法：<code>goto 标记</code>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">    label:</span><br><span class="line">    <span class="comment">// 跳转到这里继续执行的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码示例</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">goto</span> start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1 到 10 的整数之和为: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在这个示例中，start 是一个标签。程序首先初始化 sum 为 0，i 为 1。当执行到 goto start; 语句时，程序会跳转到 start: 标签处继续执行。只要 i 小于等于 10，就会不断将 i 的值累加到 sum 中，并使 i 自增 1，直到 i 大于 10 时，跳出循环并输出结果。*/</span></span><br><span class="line">```  </span><br><span class="line">优点：简单直接：在某些特定情况下，<span class="keyword">goto</span> 语句可以提供一种简单直接的跳转方式，尤其是在处理错误处理或跳出多层嵌套循环时。例如，当需要在多层嵌套的循环中遇到某个条件时立即跳出所有循环，可以使用 <span class="keyword">goto</span> 语句。</span><br><span class="line"></span><br><span class="line">缺点：  </span><br><span class="line">破坏代码结构：过度使用 <span class="keyword">goto</span> 语句会使程序的控制流程变得混乱，代码的可读性和可维护性大大降低。因为程序的执行顺序不再是按照代码的线性顺序，而是在不同的标签之间随意跳转，增加了理解代码逻辑的难度。</span><br><span class="line"></span><br><span class="line">容易导致错误：<span class="keyword">goto</span> 语句的滥用可能会导致一些难以调试的错误，例如可能会跳过变量的初始化、资源的释放等重要步骤，从而引发程序崩溃或出现未定义行为。  </span><br><span class="line"></span><br><span class="line">建议：</span><br><span class="line">由于 <span class="keyword">goto</span> 语句存在明显的缺点，在现代编程中，通常建议尽量避免使用 <span class="keyword">goto</span> 语句。可以使用更结构化的控制语句，如 <span class="keyword">if</span>-<span class="keyword">else</span>、<span class="keyword">for</span>、<span class="keyword">while</span> 等来实现程序的逻辑，这样可以使代码更加清晰、易于理解和维护。只有在极少数特殊情况下，当其他结构化控制语句无法简洁有效地实现需求时，才考虑使用 <span class="keyword">goto</span> 语句。</span><br><span class="line"></span><br><span class="line">### <span class="number">5</span> 数组</span><br><span class="line">数组就是一个集合，里面存放了相同类型的数据元素</span><br><span class="line">+ 数字的每个数据元素都是相同的数据类型</span><br><span class="line">+ 数字是由连续的内存位置组成的</span><br><span class="line">#### <span class="number">5.1</span>数组的声明</span><br><span class="line">声明数组时，需要指定数组元素的类型、数组的名称以及数组的大小  </span><br><span class="line">语法：</span><br><span class="line"><span class="number">1.</span> `类型 数组名[数组大小]`;</span><br><span class="line"><span class="number">2.</span> `类型 数组名[数组大小] = &#123;值<span class="number">1</span>，值<span class="number">2</span>, ...&#125;`;</span><br><span class="line"><span class="number">3.</span> `类型 数组名[] = &#123;值<span class="number">1</span>，值<span class="number">2</span>, ...&#125;`;</span><br><span class="line"></span><br><span class="line">#### <span class="number">5.2</span>数组的初始化</span><br><span class="line">数组可以在声明时进行初始化，也可以在声明后再赋值</span><br><span class="line">+ 声明时初始化</span><br><span class="line">```cpp</span><br><span class="line">    <span class="comment">// 初始化所有元素</span></span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 部分初始化，未指定的元素会被初始化为 0</span></span><br><span class="line">    <span class="type">int</span> numbers2[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 等价于 &#123;1, 2, 0, 0, 0&#125;</span></span><br><span class="line">    <span class="comment">// 省略数组大小，编译器会根据初始化列表的元素个数自动确定数组大小</span></span><br><span class="line">    <span class="type">int</span> numbers3[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; </span><br></pre></td></tr></table></figure><ul><li>声明后赋值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>];</span><br><span class="line">numbers[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 以此类推</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3-数组元素的访问"><a href="#5-3-数组元素的访问" class="headerlink" title="5.3 数组元素的访问"></a>5.3 数组元素的访问</h4><p>可以使用数组名和索引来访问数组中的元素。数组的索引从 0 开始，到数组大小减 1 结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 访问第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素: &quot;</span> &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 修改第三个元素</span></span><br><span class="line">    numbers[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后的第三个元素: &quot;</span> &lt;&lt; numbers[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组的长度计算<br>sizeof(数组名) &#x2F; sizeof(数组元素类型) </p></blockquote><h4 id="5-4-多维数组"><a href="#5-4-多维数组" class="headerlink" title="5.4 多维数组"></a>5.4 多维数组</h4><p>除了一维数组，C++ 还支持多维数组，最常见的是二维数组。二维数组可以看作是一个表格，有行和列。</p><ul><li>二维数组的声明和初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 数据类型 数组名[行数][列数];</span><br><span class="line">2. 数据类型 数组名[行数][列数] = &#123;&#123;值1,值2,...&#125;,&#123;值1,值2,...&#125;,...&#125;;</span><br><span class="line">3. 数据类型 数组名[行数][列数] = &#123;值1,值2,...&#125;;</span><br><span class="line">4. 数据类型 数组名[][列数] = &#123;值1,值2,...&#125;;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个 3 行 4 列的二维数组</span></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 初始化二维数组</span></span><br><span class="line"><span class="type">int</span> matrix2[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>二维数组元素的访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 访问第二行第三列的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二行第三列的元素: &quot;</span> &lt;&lt; matrix[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-5-注意事项"><a href="#5-5-注意事项" class="headerlink" title="5.5 注意事项"></a>5.5 注意事项</h4><ul><li>数组越界：访问数组时，索引必须在合法范围内（从 0 到数组大小减 1）。如果使用了超出范围的索引，会导致未定义行为，可能会引发程序崩溃或产生不可预期的结果。</li><li>数组大小固定：数组的大小在声明时就已经确定，不能在运行时改变。如果需要动态调整大小的数组，可以使用 C++ 的标准库容器，如 std::vector。</li></ul><p>以下是一个完整的示例，展示了数组的声明、初始化、访问和遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 遍历数组并输出每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;numbers[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; numbers[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h3><p>函数是一组具有特定功能的代码块，它把复杂的任务拆分成多个小任务，让代码结构更清晰，方便复用与维护。</p><h4 id="6-1-函数的定义"><a href="#6-1-函数的定义" class="headerlink" title="6.1 函数的定义"></a>6.1 函数的定义</h4><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">    // 实现具体功能的代码</span><br><span class="line">    return 返回值; // 如果返回类型不是 void，需要返回相应类型的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回类型：表明函数执行完毕后返回值的类型，若函数不返回值，返回类型为 void。</li><li>函数名：是函数的标识符，要遵循 C++ 标识符命名规则。</li><li>参数列表：由零个或多个参数构成，每个参数包含参数类型和参数名，多个参数间用逗号分隔。</li><li>函数体：是实现函数功能的代码块。</li><li>返回值：当返回类型不是 void 时，函数必须使用 return 语句返回一个与返回类型相符的值。</li></ul><h4 id="6-2-函数的调用"><a href="#6-2-函数的调用" class="headerlink" title="6.2 函数的调用"></a>6.2 函数的调用</h4><p>定义好函数后，可在其他地方调用该函数。调用函数时要提供与参数列表匹配的实参，并且可以接收函数的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个计算两个整数之和的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3函数的参数传递"><a href="#6-3函数的参数传递" class="headerlink" title="6.3函数的参数传递"></a>6.3函数的参数传递</h4><ul><li><p>函数参数传递有值传递、引用传递和指针传递三种方式。</p><p>  值传递<br>  值传递是把实参的值复制给形参，在函数内部对形参的修改不会影响实参。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 值传递函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapByValue</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 x = 3, y = 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  引用传递</p><p>  引用传递是把实参的引用传递给形参，函数内部对形参的修改会影响实参。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 引用传递函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByReference</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapByReference</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 x = 5, y = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  指针传递</p><p>  指针传递是把实参的地址传递给形参，函数内部可通过指针操作实参。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 指针传递函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapByPointer</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapByPointer</span>(&amp;x, &amp;y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 x = 5, y = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-4-函数的返回值"><a href="#6-4-函数的返回值" class="headerlink" title="6.4 函数的返回值"></a>6.4 函数的返回值</h4><p>函数可以通过 return 语句返回一个值，返回值的类型要和函数定义的返回类型一致。若返回类型是 void，则函数无需返回值，不过也可以使用 return; 语句提前结束函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 返回布尔值的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 void 的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;这是一条消息。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 可省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEven</span>(number)) &#123;</span><br><span class="line">        std::cout &lt;&lt; number &lt;&lt; <span class="string">&quot; 是偶数。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printMessage</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-5-函数重载"><a href="#6-5-函数重载" class="headerlink" title="6.5 函数重载"></a>6.5 函数重载</h4><p>函数重载指的是在同一作用域内定义多个同名函数，但这些函数的参数列表不同（参数个数、类型或顺序不同）。编译器会依据调用时提供的实参来确定调用哪个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 函数重载示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="type">double</span> result2 = <span class="built_in">add</span>(<span class="number">3.2</span>, <span class="number">5.6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数之和: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数之和: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-递归函数"><a href="#6-6-递归函数" class="headerlink" title="6.6 递归函数"></a>6.6 递归函数</h4><p>递归函数是指在函数内部调用自身的函数，递归函数通常包含递归终止条件和递归调用两部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 递归计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">factorial</span>(num);</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; 的阶乘是: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-指针"><a href="#7-指针" class="headerlink" title="7 指针"></a>7 指针</h3><h4 id="7-1-指针的声明"><a href="#7-1-指针的声明" class="headerlink" title="7.1 指针的声明"></a>7.1 指针的声明</h4><p>语法：数据类型 *指针变量名;<br>例如，声明一个指向整数的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 声明一个指向 int 类型的指针变量 ptr</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 * 是指针声明符，它表示 ptr 是一个指针变量，而不是普通变量。</p></blockquote><h4 id="7-2-指针的赋值"><a href="#7-2-指针的赋值" class="headerlink" title="7.2 指针的赋值"></a>7.2 指针的赋值</h4><p>指针变量需要被赋值为一个有效的内存地址，通常是通过取地址运算符 &amp; 获取其他变量的地址来赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;num; <span class="comment">// 将变量 num 的地址赋给指针 ptr</span></span><br></pre></td></tr></table></figure><blockquote><p>&amp;num 表示获取变量 num 的内存地址，并将其赋值给指针 ptr，此时 ptr 就指向了变量 num。</p></blockquote><h4 id="7-3-解引用操作"><a href="#7-3-解引用操作" class="headerlink" title="7.3 解引用操作"></a>7.3 解引用操作</h4><p>通过解引用运算符 * 可以访问指针所指向的内存地址中的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;num;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;指针 ptr 所指向的值: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改指针所指向的值，此时 num 的值变为 20</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;修改后 num 的值: &quot;</span> &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 *ptr 表示访问指针 ptr 所指向的内存地址中的数据。</p></blockquote><h4 id="7-4-指针和数组"><a href="#7-4-指针和数组" class="headerlink" title="7.4 指针和数组"></a>7.4 指针和数组</h4><p>指针与数组有着密切的关系。数组名本质上是一个指向数组首元素的常量指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr; <span class="comment">// 等价于 int *ptr = &amp;arr[0];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; *(ptr + i) &lt;&lt; std::endl; <span class="comment">// 等价于 arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，ptr 指向数组 arr 的首元素，通过 *(ptr + i) 可以访问数组的第 i 个元素，这与 arr[i] 是等价的。</p></blockquote><h4 id="7-5-空指针"><a href="#7-5-空指针" class="headerlink" title="7.5 空指针"></a>7.5 空指针</h4><p>空指针是一个不指向任何有效内存地址的指针。在 C++ 中，可以使用 nullptr 来初始化空指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>; <span class="comment">// 初始化空指针</span></span><br></pre></td></tr></table></figure><blockquote><p>使用空指针时，需要注意避免对其进行解引用操作，否则会导致未定义行为。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;arr[<span class="number">2</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ptr + 1 所指向的值: &quot;</span> &lt;&lt; *(ptr + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ptr - 1 所指向的值: &quot;</span> &lt;&lt; *(ptr - <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><h4 id="7-6-指针的传递"><a href="#7-6-指针的传递" class="headerlink" title="7.6 指针的传递"></a>7.6 指针的传递</h4><p>在函数调用中，可以将指针作为参数传递，这样函数可以直接操作指针所指向的数据，从而实现对原始数据的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;x, &amp;y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，swap 函数接受两个指向整数的指针作为参数，通过解引用操作交换了两个指针所指向的变量的值。</p></blockquote><h4 id="7-7-const修饰指针"><a href="#7-7-const修饰指针" class="headerlink" title="7.7 const修饰指针"></a>7.7 const修饰指针</h4><p>在 C++ 里，const 关键字可用于修饰指针，以此来限制指针的操作</p><ol><li><p>常量指针<br>定义：指向常量的指针意味着指针所指向的对象是常量，不能通过该指针来修改所指向对象的值，但指针本身可以指向其他对象。</p><p> <strong>指针的指向可以修改 但是指针指向的值不可以修改</strong><br> 语法：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 数据类型* 指针名;</span><br></pre></td></tr></table></figure><br><br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;num1;</span><br><span class="line">    <span class="comment">// 错误：不能通过指向常量的指针修改所指向的值</span></span><br><span class="line">    <span class="comment">// *ptr = 30; </span></span><br><span class="line">    ptr = &amp;num2; <span class="comment">// 正确：指针本身可以指向其他对象</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> &gt; 在上述代码中，ptr 是指向常量的指针，所以不能使用 *ptr &#x3D; 30; 来修改 num1 的值，但可以让 ptr 指向其他对象，如 ptr &#x3D; &amp;num2;。</p></li><li><p>指针常量</p><p> 定义:<br> 常量指针指的是指针本身是常量，一旦初始化后，指针就不能再指向其他对象，但可以通过该指针修改所指向对象的值。</p><p> <strong>指针的指向不可以修改，指针指向的值可以修改</strong><br> 语法：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型* const 指针名 = &amp;初始对象;</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr = &amp;num1;</span><br><span class="line">    *ptr = <span class="number">30</span>; <span class="comment">// 正确：可以通过常量指针修改所指向的值</span></span><br><span class="line">    <span class="comment">// 错误：常量指针不能指向其他对象</span></span><br><span class="line">    <span class="comment">// ptr = &amp;num2; </span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰指针和常量</p><p>定义：指向常量的常量指针表示指针本身是常量，且指针所指向的对象也是常量，既不能通过该指针修改所指向对象的值，指针也不能指向其他对象。</p><p> <strong>指针指向不可以修改 指针指向的值也不可以修改</strong><br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 数据类型* const 指针名 = &amp;初始对象;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> ptr = &amp;num1;</span><br><span class="line">    <span class="comment">// 错误：不能通过指向常量的常量指针修改所指向的值</span></span><br><span class="line">    <span class="comment">// *ptr = 30; </span></span><br><span class="line">    <span class="comment">// 错误：指向常量的常量指针不能指向其他对象</span></span><br><span class="line">    <span class="comment">// ptr = &amp;num2; </span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个示例中，ptr 是指向常量的常量指针，所以既不能使用 *ptr &#x3D; 30; 修改 num1 的值，也不能使用 ptr &#x3D; &amp;num2; 让指针指向其他对象。</p></blockquote></li></ol><h3 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8 结构体"></a>8 结构体</h3><p>在 C++ 中，结构体（struct）是一种用户自定义的数据类型，它允许将不同类型的数据组合在一起，形成一个单一的实体。结构体可以包含各种基本数据类型（如 int、float、char 等）以及其他自定义类型的成员。</p><h4 id="8-1-结构体的定义"><a href="#8-1-结构体的定义" class="headerlink" title="8.1 结构体的定义"></a>8.1 结构体的定义</h4><p>定义结构体使用 struct 关键字，后面跟着结构体的名称和成员列表，成员列表用花括号 {} 括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称 &#123;</span><br><span class="line">    数据类型 成员1;</span><br><span class="line">    数据类型 成员2;</span><br><span class="line">    // 可以有更多成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，定义一个表示学生信息的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里定义了一个名为 Student 的结构体，它包含三个成员：name（字符串类型，表示学生姓名）、age（整数类型，表示学生年龄）和 score（浮点类型，表示学生成绩）。</p></blockquote><h4 id="8-2-结构体变量的声明和初始化"><a href="#8-2-结构体变量的声明和初始化" class="headerlink" title="8.2 结构体变量的声明和初始化"></a>8.2 结构体变量的声明和初始化</h4><p>定义好结构体后，可以声明该结构体类型的变量，并对其进行初始化。</p><p>声明结构体变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student1; // 声明一个 Student 类型的变量 student1</span><br></pre></td></tr></table></figure><p>初始化结构体变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：逐个成员初始化</span></span><br><span class="line">Student student2;</span><br><span class="line">student2.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">student2.age = <span class="number">20</span>;</span><br><span class="line">student2.score = <span class="number">85.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用初始化列表</span></span><br><span class="line">Student student3 = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">21</span>, <span class="number">90.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：C++11 及以后支持的列表初始化</span></span><br><span class="line">Student student4&#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">19</span>, <span class="number">78.5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-3-访问结构体成员"><a href="#8-3-访问结构体成员" class="headerlink" title="8.3 访问结构体成员"></a>8.3 访问结构体成员</h4><p>使用成员访问运算符 . 来访问结构体变量的成员。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = &#123;<span class="string">&quot;David&quot;</span>, <span class="number">22</span>, <span class="number">88.0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; student.name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; student.age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; student.score &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-结构体数组"><a href="#8-4-结构体数组" class="headerlink" title="8.4 结构体数组"></a>8.4 结构体数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student students[<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Eve&quot;</span>, <span class="number">20</span>, <span class="number">82.0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Frank&quot;</span>, <span class="number">21</span>, <span class="number">91.5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Grace&quot;</span>, <span class="number">19</span>, <span class="number">79.0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;学生 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 信息:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; students[i].name &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; students[i].age &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; students[i].score &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-结构体指针"><a href="#8-5-结构体指针" class="headerlink" title="8.5 结构体指针"></a>8.5 结构体指针</h4><p>可以定义指向结构体的指针，通过指针访问结构体成员时，使用箭头运算符 <code>-&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = &#123;<span class="string">&quot;Henry&quot;</span>, <span class="number">23</span>, <span class="number">86.5</span>&#125;;</span><br><span class="line">    Student* ptr = &amp;student;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; ptr-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; ptr-&gt;age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; ptr-&gt;score &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-6-结构体作为函数参数"><a href="#8-6-结构体作为函数参数" class="headerlink" title="8.6 结构体作为函数参数"></a>8.6 结构体作为函数参数</h4><p>结构体可以作为函数的参数传递，传递方式有值传递和引用传递。值传递会复制整个结构体对象，而引用传递则传递结构体对象的引用，避免了复制开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudentByValue</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; s.score &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudentByReference</span><span class="params">(<span class="type">const</span> Student&amp; s)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; s.name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; s.age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; s.score &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = &#123;<span class="string">&quot;Ivy&quot;</span>, <span class="number">20</span>, <span class="number">89.0</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值传递输出:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printStudentByValue</span>(student);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;引用传递输出:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printStudentByReference</span>(student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结构体是 C++ 中一种非常有用的数据组织方式，它可以将相关的数据组合在一起，使代码更加清晰和易于维护。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tcp和Udp协议</title>
      <link href="//blogs/Tcp%E5%92%8CUdp%E5%8D%8F%E8%AE%AE.html"/>
      <url>//blogs/Tcp%E5%92%8CUdp%E5%8D%8F%E8%AE%AE.html</url>
      
        <content type="html"><![CDATA[<h3 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>TCP&#x2F;IP 协议是 Transmission Control Protocol&#x2F;Internet Protocol 的缩写，即传输控制协议 &#x2F; 网际协议，它是互联网的基础协议，由一系列协议组成。</p><h4 id="TCP-x2F-IP-协议的层次结构"><a href="#TCP-x2F-IP-协议的层次结构" class="headerlink" title="TCP&#x2F;IP 协议的层次结构"></a>TCP&#x2F;IP 协议的层次结构</h4><ul><li><strong>应用层</strong>：应用层是 TCP&#x2F;IP 协议的最高层，负责处理应用程序之间的通信。常见的应用层协议有 HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名系统）等。</li><li><strong>传输层</strong>：传输层主要负责在不同主机上的应用程序之间提供可靠的端到端通信。主要协议有 TCP 和 UDP（用户数据报协议）。TCP 提供面向连接的、可靠的字节流服务，它通过三次握手建立连接，在数据传输过程中进行差错检测和纠正，确保数据的完整性和顺序性。UDP 则提供无连接的、不可靠的数据包服务，它不保证数据的可靠传输，但具有较低的延迟，适用于对实时性要求较高的应用，如音频、视频流传输等。</li><li><strong>网络层</strong>：网络层负责处理网络之间的通信，主要协议是 IP 协议。IP 协议的主要功能是寻址和路由选择，它为每个数据包分配一个源 IP 地址和目标 IP 地址，并根据路由表将数据包从源主机传输到目标主机。此外，网络层还包括 ICMP（互联网控制报文协议），用于在网络设备之间传递控制信息和错误消息；ARP（地址解析协议），用于将 IP 地址转换为物理地址（MAC 地址）。</li><li><strong>数据链路层</strong>：数据链路层负责将网络层传来的数据包封装成帧，并通过物理网络进行传输。它主要处理物理地址、数据成帧、介质访问控制等问题，确保数据在本地网络中的可靠传输。常见的数据链路层协议有以太网协议、PPP（点对点协议）等。</li></ul><h4 id="TCP-x2F-IP-协议的工作原理"><a href="#TCP-x2F-IP-协议的工作原理" class="headerlink" title="TCP&#x2F;IP 协议的工作原理"></a>TCP&#x2F;IP 协议的工作原理</h4><ul><li><strong>数据封装与解封装</strong>：当应用程序发送数据时，数据从应用层开始，依次经过传输层、网络层、数据链路层，每一层都会在数据上添加相应的首部信息，进行封装。在接收端，数据则从数据链路层开始，依次向上经过各层，每一层根据首部信息进行解封装，提取出本层需要处理的数据，并将剩余部分传递给上一层，直到数据到达应用层。</li><li><strong>连接建立与释放</strong>：以 TCP 协议为例，建立连接时，客户端和服务器之间通过三次握手来确认双方的连接状态。连接释放时，通常需要四次挥手来确保双方的数据都已传输完毕，并安全地关闭连接。</li><li><strong>路由选择</strong>：在网络层，IP 协议根据目标 IP 地址和路由表来确定数据包的传输路径。路由器会根据网络拓扑结构和路由算法，不断地转发数据包，直到数据包到达目标主机所在的网络。</li></ul><h4 id="TCP-协议特点"><a href="#TCP-协议特点" class="headerlink" title="TCP 协议特点"></a>TCP 协议特点</h4><ul><li><strong>面向连接</strong>：在进行数据传输之前，TCP 需要通过 “三次握手” 建立可靠的连接，确保通信双方都具备发送和接收数据的能力，传输结束后，还需通过 “四次挥手” 断开连接。</li><li><strong>可靠传输</strong>：TCP 通过多种机制保证数据传输的可靠性。它使用序号对发送的每个字节进行编号，接收方根据序号按序接收数据，并通过确认机制（ACK）告知发送方数据是否成功接收。若发送方在一定时间内未收到确认信息，会自动重传未被确认的数据。</li><li><strong>拥塞控制</strong>：TCP 能够根据网络的拥塞情况动态调整发送数据的速率。当网络拥塞时，会降低发送速率，避免进一步加重网络负担；当网络状况好转时，逐渐增加发送速率，以充分利用网络带宽。</li><li><strong>流量控制</strong>：通过滑动窗口机制实现。接收方会告知发送方自己的接收窗口大小，发送方根据这个窗口大小来控制发送数据的量，防止发送方发送数据过快，导致接收方来不及处理而造成数据丢失。</li></ul><h4 id="UDP-协议特点"><a href="#UDP-协议特点" class="headerlink" title="UDP 协议特点"></a>UDP 协议特点</h4><ul><li><strong>无连接</strong>：UDP 在传输数据之前不需要建立连接，发送方只需将数据封装成数据报发送出去，接收方在接收到数据报后也不需要发送确认信息。这种方式减少了建立和断开连接的开销，提高了传输效率。</li><li><strong>不可靠传输</strong>：UDP 不保证数据的可靠传输，它不提供确认、重传、排序等机制。数据在传输过程中可能会出现丢失、乱序等情况，但 UDP 不会进行处理。</li><li><strong>开销小</strong>：由于 UDP 不需要建立连接和维护复杂的状态信息，因此其协议开销较小，传输速度快。</li><li><strong>无拥塞控制</strong>：UDP 没有内置的拥塞控制机制，无论网络状况如何，发送方都会以恒定的速率发送数据。这可能会在网络拥塞时导致数据包丢失增加，但对于一些对实时性要求较高的应用来说，这种特性是可以接受的。</li></ul><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><ul><li><p><strong>可靠性</strong>：TCP 提供可靠的数据传输，适用于对数据准确性要求较高的场景，如文件传输、电子邮件等；UDP 不保证数据的可靠传输，适用于对实时性要求较高、对少量数据丢失不太敏感的场景，如实时音视频流、在线游戏等。</p></li><li><p><strong>连接性</strong>：TCP 是面向连接的协议，在传输数据前需要建立连接，传输结束后需要断开连接；UDP 是无连接的协议，不需要建立和维护连接，直接进行数据传输。</p></li><li><p><strong>传输效率</strong>：由于 UDP 不需要建立连接、进行确认和重传等操作，因此其传输效率通常比 TCP 高，尤其是在数据量较小、对实时性要求较高的场景下。</p></li><li><p><strong>传输顺序</strong>：TCP 能够保证数据按照发送的顺序到达接收方；UDP 不保证数据的顺序，数据可能会乱序到达。</p></li><li><p><strong>拥塞控制</strong>：TCP 具有拥塞控制机制，能够根据网络拥塞情况动态调整发送速率；UDP 没有拥塞控制机制，可能会在网络拥塞时加重网络负担。</p><p>  <img src="https://thumbsnap.com/i/WcHCRmbw.jpg" alt="udp和tcp区别"></p></li></ul><h4 id="TCP端口号序号确认号和标志位"><a href="#TCP端口号序号确认号和标志位" class="headerlink" title="TCP端口号序号确认号和标志位"></a>TCP端口号序号确认号和标志位</h4><ul><li><p>TCP端口号<br>TCP的连接是需要四个要素确定唯一一个连接：<br><strong>（源IP，源端口号）+ （目地IP，目的端口号）</strong><br>所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递<br>源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16&#x3D;65535<br>另外1024以下是系统保留的，从1024-65535是用户使用的端口范围</p></li><li><p>TCP的序号和确认号：</p><ul><li><strong>32位序号 seq</strong>：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。</li><li><strong>32位确认号 ack</strong>：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。</li></ul></li><li><p>TCP的标志位<br>每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。<br>用的最广泛的标志是 SYN，ACK 和 FIN，用于建立连接，确认成功的段传输，最后终止连接。    </p><ol><li>SYN：简写为S，同步标志位，用于建立会话连接，同步序列号；</li><li>ACK： 简写为.，确认标志位，对已接收的数据包进行确认；</li><li>FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；</li><li>PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；</li><li>RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；</li><li>URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；</li></ol></li></ul><h4 id="TCP协议的三次握手和四次挥手的过程"><a href="#TCP协议的三次握手和四次挥手的过程" class="headerlink" title="TCP协议的三次握手和四次挥手的过程"></a>TCP协议的三次握手和四次挥手的过程</h4><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式，所以需要四次挥手关闭连接。</p><ul><li><p>三次握手</p><ul><li><p><strong>第一次握手</strong>：客户端向服务器发送一个 SYN（同步）包，其中包含客户端的初始序列号（Sequence Number，seq），假设为 x，该包表示客户端请求与服务器建立连接。</p></li><li><p><strong>第二次握手</strong>：服务器接收到客户端的 SYN 包后，会向客户端发送一个 SYN + ACK（同步确认）包。这个包中，服务器将客户端的序列号加 1 作为确认号（Acknowledgment Number，ack），即 ack &#x3D; x + 1，表示已成功收到客户端的 SYN 包。同时，服务器也会发送自己的初始序列号，假设为 y。</p></li><li><p><strong>第三次握手</strong>：客户端收到服务器的 SYN + ACK 包后，会向服务器发送一个 ACK 包。该包的确认号为服务器的序列号加 1，即 ack &#x3D; y + 1，而序列号为客户端在第一次握手中发送的序列号加 1，即 seq &#x3D; x + 1。服务器收到这个 ACK 包后，连接建立成功。  </p><p>  <img src="https://thumbsnap.com/i/JD3fXZM1.jpg"></p></li></ul></li><li><p>四次挥手</p><ul><li><p><strong>第一次挥手</strong>：客户端发送一个 FIN（结束）包，用来关闭客户端到服务器的数据传输。这个包中包含客户端的序列号，假设为 u，此时客户端进入 FIN_WAIT_1 状态。</p></li><li><p><strong>第二次挥手</strong>：服务器收到客户端的 FIN 包后，会发送一个 ACK 包作为应答，确认号为客户端的序列号加 1，即 ack &#x3D; u + 1，序列号为服务器当前的序列号，假设为 v。此时服务器进入 CLOSE_WAIT 状态，客户端收到 ACK 包后进入 FIN_WAIT_2 状态。</p></li><li><p><strong>第三次挥手</strong>：服务器处理完剩余的数据后，会向客户端发送一个 FIN 包，用来关闭服务器到客户端的数据传输。这个包的序列号为 w（通常 w &#x3D; v + 1，因为之前可能有数据传输），确认号仍然是 ack &#x3D; u + 1，此时服务器进入 LAST_ACK 状态。</p></li><li><p><strong>第四次挥手</strong>：客户端收到服务器的 FIN 包后，会发送一个 ACK 包进行确认，确认号为服务器的序列号加 1，即 ack &#x3D; w + 1，序列号为 u + 1。客户端发送完这个 ACK 包后进入 TIME_WAIT 状态，等待一段时间（通常为 2 倍的 MSL，即最长报文段寿命）后，若没有收到服务器的重传请求，则认为连接已成功关闭，客户端彻底释放资源。服务器收到 ACK 包后，立即关闭连接，释放资源。</p><p>  <img src="https://thumbsnap.com/i/dorkrbkT.jpg"></p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS解析</title>
      <link href="//blogs/HTTPS%E8%A7%A3%E6%9E%90.html"/>
      <url>//blogs/HTTPS%E8%A7%A3%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul><li><p>定义与基本功能</p><ul><li>HTTP 是互联网上信息传递与交互的基础协议之一，它规定了客户端（如浏览器）和服务器之间如何进行数据交换。其核心功能是让客户端能够向服务器发送请求，获取服务器上存储的各种资源，如网页、图片、视频、文件等，同时服务器能够根据客户端的请求，将相应的资源返回给客户端。</li></ul></li><li><p>工作原理</p><ul><li><strong>请求 - 响应模型</strong> 客户端发起一个 HTTP 请求，该请求包含了请求方法（如 GET、POST 等）、请求头（包含一些关于请求的附加信息，如客户端类型、所请求资源的类型等）以及请求体（如果有的话，通常用于 POST 请求来传递数据）。服务器接收到请求后，会根据请求的内容进行处理，并返回一个 HTTP 响应。响应也包含响应头（提供关于响应的信息，如状态码、内容类型等）和响应体（即客户端所请求的资源内容）。</li><li><strong>无状态性</strong> HTTP 是无状态协议，意味着每个请求都是独立的，服务器不会在不同请求之间记住客户端的状态信息。这使得 HTTP 协议简单且易于实现，但在某些需要跟踪用户状态的应用场景中，就需要通过其他技术（如 Cookie、Session 等）来弥补这一不足。</li></ul></li><li><p>常用方法</p><ul><li><p><strong>GET方法</strong>用于从服务器获取资源，通常用于获取网页、查询数据等操作。请求的数据会附加在 URL 后面，以问号分隔，例如<a href="https://example.com/api/data?param1=value1&param2=value2%E3%80%82">https://example.com/api/data?param1=value1&amp;param2=value2。</a></p></li><li><p><strong>POST方法</strong>用于向服务器提交数据，比如用户登录、注册时提交表单数据，或者上传文件等操作。数据包含在请求体中，而不是 URL 中，这样可以传输更大的数据量，并且相对 GET 方法更加安全，因为数据不会暴露在 URL 中。</p></li></ul><p>  http请求过程<br>  <img src="https://thumbsnap.com/i/tu9UEN7D.jpg"></p></li></ul><h3 id="http-请求方式"><a href="#http-请求方式" class="headerlink" title="http 请求方式"></a>http 请求方式</h3><ul><li><strong>GET</strong>：最常用的请求方式之一，用于从服务器获取资源。它将参数包含在 URL 中，以键值对的形式拼接在 URL 后面，如 <a href="https://example.com/api/users?id=123%E3%80%82GET">https://example.com/api/users?id=123。GET</a> 请求的参数有长度限制（不同浏览器和服务器可能有不同的限制，一般在 2048 个字符左右），并且请求的参数会显示在浏览器的地址栏中，因此不适合传输敏感信息。GET 请求是幂等的，即多次执行相同的 GET 请求，对服务器资源的影响是相同的，不会产生额外的副作用。例如，多次获取一篇文章的内容，结果都是相同的文章数据。</li><li><strong>POST</strong>：用于向服务器提交数据，以创建新的资源。参数通常放在请求体中，而不是 URL 里。例如，在用户注册时，将用户的注册信息（如用户名、密码、邮箱等）通过 POST 请求发送到服务器。POST 请求没有固定的参数长度限制，适合传输大量数据。与 GET 不同，POST 不是幂等的，因为每次执行 POST 请求，都会在服务器上创建新的资源，多次提交可能会导致多个相同资源的产生，例如多次提交注册表单可能会创建多个用户账号。</li></ul><h4 id="post请求格式"><a href="#post请求格式" class="headerlink" title="post请求格式"></a>post请求格式</h4><ul><li>请求参数<br>概念：POST 请求的参数通常是指发送给服务器用于处理请求的相关数据。与 GET 请求不同，POST 请求的参数一般不直接显示在 URL 中，而是放在请求体里（但也存在将参数放在 URL 中的情况，不过不常见）。<br>用途：例如在用户登录时，用户名和密码作为参数通过 POST 请求发送给服务器，服务器根据这些参数来验证用户身份；或者在提交表单数据（如注册信息、订单详情等）时，使用 POST 请求传递参数。<br>形式：POST 请求参数常见的格式有 URL 编码格式（application&#x2F;x-www-form-urlencoded）和 JSON 格式（application&#x2F;json）。在 URL 编码格式中，参数以键值对形式排列，并用 &amp; 符号连接，如 username&#x3D;John&amp;password&#x3D;123456；而 JSON 格式则是将参数组织成 JSON 对象的形式，例如 {“username”: “John”, “password”: “123456”}。</li><li>请求头<br>概念：请求头是 HTTP 请求的一部分，它包含了关于请求的元数据信息，用于向服务器传达请求的相关属性、客户端的能力以及其他一些控制信息等。<br>常见请求头字段<br>Content-Type：用于指示请求体中数据的媒体类型。如前面提到的，当使用 URL 编码格式时，值为 application&#x2F;x-www-form-urlencoded；使用 JSON 格式时，值为 application&#x2F;json；如果是上传文件，通常是 multipart&#x2F;form-data。<br>User-Agent：包含了发出请求的客户端应用程序（如浏览器名称和版本、操作系统等）的信息，服务器可以根据这些信息来提供不同的响应或进行一些统计分析。<br>Accept：告诉服务器客户端能够接受的响应内容类型，如 Accept: text&#x2F;html 表示客户端希望接收 HTML 格式的响应。<br>Authorization：用于身份验证，包含了客户端的认证信息（如令牌、用户名和密码等），服务器通过验证该字段来确认客户端的权限。</li><li>请求体<br>请求体（Request Body）<br>概念：请求体是 POST 请求中承载实际数据的部分，它包含了客户端要发送给服务器的具体内容，根据 Content-Type 字段指定的格式进行组织。<br>数据类型：请求体中的数据可以是文本、JSON 对象、XML 文档、表单数据或者二进制数据（如上传文件）等。例如，在使用 AJAX 发送 POST 请求提交用户评论时，请求体可能是一段文本内容；而在与 RESTful API 交互时，请求体可能是一个 JSON 格式的对象，描述了要创建或更新的资源信息。<br>作用：服务器会根据请求体中的数据进行相应的处理，如存储数据到数据库、更新资源等操作。例如，当用户在网页上提交一篇文章时，文章的标题、内容等信息会被包含在请求体中发送到服务器，服务器再将这些信息保存到服务器的存储系统中。</li></ul><h4 id="post请求示例"><a href="#post请求示例" class="headerlink" title="post请求示例"></a>post请求示例</h4><ol><li><p>使用 fetch API</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>POST Request Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义请求的 URL</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> url = <span class="string">&#x27;http://example.com/api/login&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义请求体数据，以 JavaScript 对象形式表示</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&quot;username&quot;</span>: <span class="string">&quot;test_user&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&quot;password&quot;</span>: <span class="string">&quot;test_password&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置请求选项</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> options = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">headers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发送 POST 请求</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(url, options)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Response Data:&#x27;</span>, data);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用 XMLHttpRequest  </p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">title</span>&gt;</span>XMLHttpRequest POST Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">const</span> url = <span class="string">&#x27;https://example.com/api&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">const</span> params = &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">username</span>: <span class="string">&#x27;JohnDoe&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                            <span class="attr">age</span>: <span class="number">30</span></span></span><br><span class="line"><span class="language-javascript">                        &#125;;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">const</span> jsonParams = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                        xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">                        xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                            &#125;</span></span><br><span class="line"><span class="language-javascript">                        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                        xhr.<span class="title function_">send</span>(jsonParams);</span></span><br><span class="line"><span class="language-javascript">                    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>表单提交</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Form POST Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://example.com/api&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JohnDoe&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;age&quot;</span>&gt;</span>Age:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="post请求体格式"><a href="#post请求体格式" class="headerlink" title="post请求体格式"></a>post请求体格式</h4><ul><li><p>JSON<br>说明：JavaScript Object Notation 的缩写，是一种轻量级的数据交换格式，易于阅读和编写，也方便机器解析和生成。<br>场景：在前后端分离的 Web 应用程序中广泛使用，尤其是在使用 RESTful API 进行数据交互时。例如，当前端向服务器提交用户注册信息、登录信息、复杂的表单数据，或者请求服务器返回特定格式的结构化数据时，通常会使用 JSON 格式。因为它能够很好地表示复杂的对象结构，并且与 JavaScript 语言原生支持，便于在前端进行处理。</p><ul><li>json格式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表单数据（Form Data）<br>说明：分为两种类型，一种是 <code>application/x-www-form-urlencoded</code>，另一种是 <code>multipart/form - data</code>。<strong>application&#x2F;x-www - form - urlencoded 格式会将表单数据编码为键值对，通过 &amp; 符号分隔，常用于提交简单的文本数据</strong>。<strong>multipart&#x2F;form - data 则用于上传文件或包含非文本数据的表单，它会为每个表单字段和文件创建一个独立的部分，并在请求体中进行分隔</strong>。<br>场景：当用户通过 HTML 表单提交数据，如注册、登录、搜索等操作时，通常会使用 application&#x2F;x - www - form - urlencoded 格式。而在文件上传的场景，比如用户上传头像、文档、图片等文件到服务器时，就需要使用 multipart&#x2F;form - data 格式。</p><ul><li>application&#x2F;x-www-form-urlencoded  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=John&amp;age=30</span><br></pre></td></tr></table></figure></li><li>multipart&#x2F;form - data格式  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;photo&#x27;</span>, fileInput.<span class="property">files</span>[<span class="number">0</span>]); </span><br></pre></td></tr></table></figure></li></ul></li><li><p>XML<br>说明：Extensible Markup Language 的缩写，是一种标记语言，用于存储和传输数据。它具有严格的语法规则，并且可以自定义标签，使得数据具有良好的结构性和可扩展性。<br>场景：在一些传统的企业级应用、Web 服务（如 SOAP 协议）以及与某些特定的 XML - based 系统进行交互时，XML 格式较为常用。例如，银行系统之间的数据交互、政府机构的电子政务系统等，可能会因为历史原因或对数据结构的严格要求而使用 XML 格式来确保数据的准确性和完整性。</p></li><li><p>纯文本（Plain Text）<br>说明：简单的文本内容，没有特定的格式或结构，通常用于传输简单的文本信息，如日志文件、简单的消息等。</p></li></ul><h4 id="http不安全性"><a href="#http不安全性" class="headerlink" title="http不安全性"></a>http不安全性</h4><ul><li>明文传输</li><li>数据完整性无法保证</li><li>缺乏身份验证机制</li><li>易受中间人攻击：</li></ul><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p>HTTPS 即超文本传输安全协议，它是在 HTTP 基础上通过加入 SSL&#x2F;TLS 协议来实现安全通信的协议。</p><ul><li>SSL（安全套接字层）&#x2F;TLS （传输层安全协议）<ul><li>加密：通过对称加密算法对传输的数据进行加密，使数据在网络上以密文形式传输，防止数据被窃取或监听。  </li><li>身份认证：利用数字证书来验证通信双方的身份，确保客户端和服务器 能够确认对方的身份是真实可靠的，防止中间人攻击。        </li><li>数据完整性保护：使用消息认证码或哈希函数，对数据进行校验，确保数据在传输过程中没有被篡改或损坏。</li></ul></li></ul><blockquote><p>除了HTTPS协议外，TLS可以被应用与任何基于TCP&#x2F;IP协议的上层协议的或应用程序，如SFTP协议，SMTP协议，数据库间通讯加密等。</p></blockquote><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密使用相同的密钥对数据进行加密和解密操作。也就是说，加密方使用某个密钥将明文数据转换为密文，而解密方使用同一个密钥将密文还原为明文。</p><ul><li><p><strong>原理</strong>  </p><ul><li>发送方将明文数据按照一定的加密算法，在密钥的作用下进行变换，生成密文。接收方收到密文后，使用相同的密钥和对应的解密算法对密文进行处理，还原出原始的明文。例如，常见的对称加密算法 AES（高级加密标准），它将明文分成固定长度的块，然后在密钥的控制下对每个块进行一系列复杂的变换操作，实现加密；解密时则进行相反的操作。</li></ul></li><li><p><strong>特点</strong></p><ul><li>加密速度快：由于使用同一密钥进行加密和解密，计算量相对较小，所以加密和解密的速度都比较快，适合对大量数据进行加密处理。  </li><li>密钥管理复杂：通信双方必须共享相同的密钥，并且要确保密钥的安全性。如果密钥泄露，那么加密的数据就会失去保密性。而且当通信对象较多时，密钥的分发和管理会变得困难。<br>对称加密在数据加密领域有着广泛的应用，常被用于对文件、数据库中的敏感数据等进行加密保护，以确保数据的保密性。</li></ul><p>  对称加密过程<br>  <img src="https://thumbsnap.com/i/YreU5sEG.png"></p><p>  对称加密缺点<br>  <img src="https://thumbsnap.com/i/5oPCHeMZ.png"></p></li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密使用一对密钥，即公钥和私钥。公钥可以公开，用于加密数据；私钥则由用户自己保密，用于解密数据。用公钥加密的数据只能用对应的私钥解密，反之亦然。  </p><ul><li><p><strong>原理</strong></p><ul><li>假设用户 A 要向用户 B 发送加密信息。首先，B 生成一对密钥（公钥和私钥），并将公钥公开给 A。A 使用 B 的公钥对要发送的信息进行加密，然后将密文发送给 B。B 收到密文后，使用自己的私钥进行解密，从而得到原始信息。</li></ul></li><li><p><strong>特点</strong>  </p><ul><li>安全性高：公钥公开，私钥保密，即使攻击者获取了公钥和密文，也难以通过公钥推算出私钥来解密数据，安全性较高。</li></ul><ul><li>密钥管理方便：不需要像对称加密那样在通信双方之间共享密钥，只需要保护好自己的私钥，公钥可以随意公开，便于密钥的管理和分发。</li><li>加密速度慢：相比对称加密，非对称加密的计算量较大，加密和解密速度较慢，所以通常不适合对大量数据进行加密。</li></ul><p>  非对称加密过程<br>  <img src="https://thumbsnap.com/i/pkuNhWuW.png"></p><p>  非对称加密缺点<br>  <img src="https://thumbsnap.com/i/UwCvRC9W.png"></p><blockquote><p>公钥加密 私钥解密  不可逆<br>公钥获取的时候可能被篡改成其他的公钥</p></blockquote></li></ul><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书是由权威的证书颁发机构（CA）颁发的，包含了证书持有者的身份信息、公钥以及 CA 的数字签名等内容的电子文件。它的主要作用是在网络通信中，通过验证数字证书的真实性和有效性，来确认通信双方的身份，保证数据传输的安全性和完整性，防止中间人攻击和假冒身份等安全问题。</p><ul><li><p><strong>内容</strong></p><ul><li>证书持有者信息：包括证书持有者的名称、组织信息、电子邮件地址等，用于标识证书的所有者。</li><li>公钥：证书持有者的公钥，用于加密数据和验证数字签名。</li><li>证书颁发机构信息：包含颁发证书的 CA 的名称、标识等信息。</li><li>数字签名：CA 使用自己的私钥对证书的其他内容进行签名，用于验证证书的完整性和真实性。</li><li>有效期：规定了证书的有效使用期限，超过有效期，证书将被视为无效</li></ul></li><li><p><strong>工作原理</strong> </p><h5 id="服务器证书的验证"><a href="#服务器证书的验证" class="headerlink" title="服务器证书的验证"></a>服务器证书的验证</h5><ol><li><strong>客户端发起请求</strong>： 客户端向服务器发送 HTTPS 请求，请求中包含客户端支持的加密算法和协议版本等信息。</li><li><strong>服务器响应证书</strong>：服务器收到请求后，将自己的数字证书发送给客户端。该证书包含服务器的公钥、证书颁发机构（CA）的信息、数字签名等内容。  </li><li><strong>客户端验证证书</strong>：客户端收到证书后，首先检查证书的格式是否正确，然后使用内置的 CA 根证书公钥来验证证书上 CA 的数字签名。如果签名验证通过，说明证书是由可信的 CA 颁发的，且证书内容未被篡改。接着，客户端检查证书的有效期、服务器的域名是否与证书中的域名匹配等。若所有检查都通过，客户端就认为服务器的身份是可信的。</li></ol><h5 id="密钥交换与加密通信"><a href="#密钥交换与加密通信" class="headerlink" title="密钥交换与加密通信"></a>密钥交换与加密通信</h5><ol><li><strong>生成会话密钥</strong>： 客户端向服务器发送 HTTPS 请求，请求中包含客户端支持的加密算法和协议版本等信息。</li><li><strong>服务器解密会话密钥</strong>：服务器收到加密的会话密钥后，使用自己的私钥进行解密，得到会话密钥。</li><li><strong>对称加密通信</strong>：双方使用会话密钥通过对称加密算法对通信数据进行加密和解密。这样，在保证数据传输安全的同时，利用对称加密的高效性来处理大量数据。</li></ol></li></ul><p> <strong>数据完整性保护和验证数字证书的真实性</strong></p><p> 数字证书主要通过数字签名技术和哈希算法来保证数据的完整性</p><ul><li><p><strong>数字签名技术</strong>：数字证书中包含证书颁发机构（CA）的数字签名。CA 使用自己的私钥对证书中的相关信息，如证书持有者的身份信息、公钥等进行签名。当用户收到数字证书时，可使用 CA 的公钥来验证数字签名。如果签名验证通过，说明证书内容在传输过程中未被篡改，因为若有人篡改了证书内容，那么用 CA 公钥验证签名时就会失败，从而保证了数字证书本身的完整性和真实性。</p></li><li><p><strong>哈希算法</strong>:在数据传输过程中，发送方会使用哈希算法对要传输的数据进行计算，生成一个固定长度的哈希值，这个哈希值就像是数据的 “指纹”。然后，发送方会将数据和哈希值一起发送给接收方。接收方收到数据后，会使用相同的哈希算法对收到的数据进行计算，得到一个新的哈希值。接着，接收方将新计算出的哈希值与发送方发送过来的哈希值进行对比。如果两个哈希值相同，就可以认为数据在传输过程中没有被修改，保证了数据的完整性；如果两个哈希值不同，那就说明数据在传输过程中被篡改过。</p><blockquote><p>此外，数字证书还通过在证书中明确指定证书的有效期、证书持有者的身份等信息，防止证书被冒用或滥用，进一步为数据完整性提供保障。因为只有在有效期内、由合法持有者使用的证书，才能保证相关数据的完整性和安全性。</p></blockquote></li></ul><p><strong>申请证书流程</strong>   </p><ul><li><p>准备工作   </p><ul><li>确定域名：明确需要申请数字证书的网站域名，确保该域名已完成注册且归申请人所有或申请人具有合法的使用权限。</li><li>服务器配置：保证服务器满足 HTTPS 相关要求，如具备支持 SSL&#x2F;TLS 协议的软件和硬件环境。通常需要在服务器上安装相应的 Web 服务器软件（如 Apache、Nginx 等），并进行初步的配置。</li></ul></li><li><p>选择合适的证书类型：HTTPS 证书主要分为单域名证书、多域名证书和通配符证书等。此外，根据安全等级的不同，还有 DV SSL 证书（域名验证）、OV SSL 证书（组织验证）和 EV SSL 证书（扩展验证）。需根据网站的需求和预算来选择。</p></li><li><p>选择证书颁发机构（CA）：证书颁发机构是负责验证和签发 HTTPS 证书的机构。常见的 CA 包括 Digicert、Globalsign 和 Sectigo 等。选择时要考虑其信誉、客户服务以及支持的证书类型。</p></li><li><p>生成证书签名请求（CSR）：CSR 是一段包含服务器和域名信息的加密文本。可使用 openssl 工具或服务器控制面板来生成，生成过程中会产生公钥和私钥，公钥包含在 CSR 中，私钥需妥善保存在服务器上。  </p><ul><li>CSR文件的创建<ul><li><p>在线（不建议）</p></li><li><p>本地创建</p><ol><li><code>openssl version</code> 获取openssl版本</li><li>创建密钥<br> &gt; 加密算法：<br>     RSA：目前最广泛使用的加密算法<br>     DSA: 由于安全原因已经不推荐使用<br>     ECDSA：目前仍未被广泛使用<br>     EdDSA：目前仍未被广泛使用<br> &gt;密钥大小：<br>     用于指定密钥的大小，密钥越大越安全，加密时间越长，对于RSA加密，确保密钥长度为2048位<br> &gt; 密钥密码（可选）：<br>     为创建的密钥指定一个密码，来进一步保护密钥安全性，但同时也带来了一些密钥使用的复杂性<br><br> 使用genpkey指令<br><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048</span><br><span class="line">    ```  </span><br><span class="line">    &gt;使用 genpkey 生成一个 2048 位的 RSA 私钥文件 private.key。</span><br><span class="line"></span><br><span class="line">这将在当前目录下创建一个名为private_key.pem的文件，其中包含你的私钥   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.创建证书签名请求（生成CSR）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">            openssl req -new -key private.key -out certificate.csr</span><br></pre></td></tr></table></figure><blockquote><p>创建一个新的证书请求，使用 private.key 作为私钥，输出为 certificate.csr。<br> 在执行上述命令后，需要你提供一些信息，例如国家、州&#x2F;省、城市、组织名、组织单位等。例如：。<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:CN #国家</span><br><span class="line">State or Province Name (full name) [Some-State]:Liao Ning #州/省市</span><br><span class="line">Locality Name (eg, city) []:Dalian #城市</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany #组织名</span><br><span class="line">Organizational Unit Name (eg, section) []:IT Department #部门</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:www.example.com #域名</span><br><span class="line">Email Address []:admin@example.com #邮箱</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 4. 创建自签名证书（可选）<br> 自签名证书一般用于测试或内部环境，不被公共信任，但可用于验证加密连接。<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private.key -out certificate.crt -days 365</span><br></pre></td></tr></table></figure><br>使用 req 生成自签名证书，-new 表示创建新请求，-x509 指明生成自签名证书，-key 指定私钥文件，-out 指定输出的证书文件名，-days 设置证书有效期为 365 天。</p></blockquote></li></ol></li></ul></li></ul></li><li><p>提交证书申请：通过 CA 的在线申请界面提交申请，填写组织信息、提供 CSR，并选择证书类型和期限。对于 EV 证书等一些类型，可能需要提供额外的公司文件和法律文件作为验证材料。<br>验证和颁发证书：CA 会对提交的域名和组织信息进行验证，方式包括电子邮件验证、DNS 验证和电话验证等。验证通过后，CA 将签发 HTTPS 证书并发送给申请者。</p></li><li><p>安装和配置证书：将证书文件和私钥文件上传到服务器，并配置服务器软件（如 Apache、Nginx）以启用 HTTPS 连接。配置完成后，通过浏览器访问网站，检查地址栏是否显示安全锁标志以及证书信息是否正确，以确认 HTTPS 数字证书是否成功安装并生效。</p></li></ul><h4 id="SSL-x2F-TLS握手过程"><a href="#SSL-x2F-TLS握手过程" class="headerlink" title="SSL&#x2F;TLS握手过程"></a>SSL&#x2F;TLS握手过程</h4><p>SSL&#x2F;TLS 握手过程是在客户端和服务器之间建立安全连接时发生的一系列步骤，用于协商加密算法、验证身份和交换密钥。</p><ol><li><p>客户端发起握手</p><ul><li>客户端向服务器发送一个 ClientHello 消息，其中包含客户端支持的 SSL&#x2F;TLS 版本、加密算法列表、压缩方法等信息，以及一个随机数 ClientRandom。</li></ul></li><li><p>服务器响应</p><ul><li>服务器收到 ClientHello 后，发送 ServerHello 消息作为响应。该消息包含服务器选择的 SSL&#x2F;TLS 版本、加密算法、压缩方法等，以及另一个随机数 ServerRandom。</li><li>接着，服务器发送 Certificate 消息，将自己的数字证书发送给客户端，证书中包含服务器的公钥以及相关的身份信息。如果服务器需要验证客户端的身份，还会发送 CertificateRequest 消息，要求客户端提供证书。</li><li>最后，服务器发送 ServerHelloDone 消息，表明服务器的握手参数发送完毕。</li></ul></li><li><p>客户端验证与密钥交换</p><ul><li>客户端收到服务器的消息后，首先验证服务器的数字证书是否有效，包括检查证书的颁发机构、有效期、是否被吊销等。如果证书无效，客户端将终止连接。</li><li>验证通过后，客户端生成一个预主密钥 Pre - Master - Secret，并用服务器证书中的公钥加密，通过 ClientKeyExchange 消息发送给服务器。</li><li>客户端还会根据之前交换的随机数和预主密钥，计算出会话密钥（主密钥 Master - Secret），用于后续的数据加密和解密。同时，客户端发送 ChangeCipherSpec 消息，告知服务器后续的通信将使用新协商的加密算法和密钥。然后，客户端使用新的密钥发送一个 Finished 消息，该消息包含了之前所有握手消息的摘要，用于验证握手过程的完整性。</li></ul></li><li><p>服务器密钥交换与响应</p><ul><li>服务器收到 ClientKeyExchange 消息后，使用自己的私钥解密得到预主密钥，然后与客户端一样根据随机数和预主密钥计算出会话密钥。</li><li>服务器发送 ChangeCipherSpec 消息，表明将切换到新的加密算法和密钥进行通信。接着，服务器也发送一个 Finished 消息，包含之前握手消息的摘要，用于让客户端验证服务器的身份和握手过程的完整性。<br>至此，SSL&#x2F;TLS 握手完成，客户端和服务器可以使用协商好的会话密钥进行安全的数据传输。</li></ul><p> SSL&#x2F;TLS握手过程<br> <img src="https://thumbsnap.com/i/8eZMewML.png"></p></li></ol><blockquote><p>私钥虽然不能加密，但是可以签名：<br>公钥加密，私钥解密。<br>私钥签名，公钥验签。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常用操作</title>
      <link href="//blogs/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html"/>
      <url>//blogs/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git 是一款分布式版本控制系统，被广泛应用于软件开发、文档管理等领域。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>分布式：与集中式版本控制系统不同，Git 没有中心服务器，每个开发者的本地计算机就是一个完整的版本库，包含了项目的所有历史记录和版本信息。这使得开发者可以在本地进行完整的开发、提交、暂存等操作，而无需依赖网络连接到中心服务器。</li><li>高效性：Git 采用了一种高效的对象存储模型，能够快速地进行版本提交、切换分支、合并等操作。它只存储文件的差异，而不是整个文件的副本，大大节省了存储空间，同时也提高了操作速度。</li><li>强大的分支管理：创建、切换和合并分支非常容易且高效，允许开发者在不影响主代码库的情况下，并行地进行不同功能的开发、实验或修复 bug。</li></ul><h4 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h4><ul><li>初始化仓库：在项目目录下执行git init命令，将该目录初始化为 Git 仓库，此时会在目录下生成一个隐藏的.git文件夹，用于存储版本数据和相关配置。</li><li>添加文件到暂存区：使用git add命令将需要跟踪的文件添加到暂存区。例如，git add file1.txt将file1.txt文件添加到暂存区。</li><li>提交暂存区的文件：执行git commit -m “提交信息”命令，将暂存区的文件提交到本地仓库，其中-m参数后面的字符串是对本次提交的描述，方便后续查看提交历史时了解此次修改的目的。</li><li>推送本地提交到远程仓库：如果有远程仓库（如 GitHub、GitLab 等），可以使用git push origin master命令将本地的提交推送到远程仓库的master分支。这里的origin是远程仓库的别名，通常在克隆远程仓库时自动设置。</li><li>从远程仓库拉取最新代码：使用git pull origin master命令从远程仓库的master分支拉取最新的代码到本地，与本地代码合并。</li></ul><h4 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h4><p>配置级别及存储位置</p><ul><li><p>系统级配置：对系统上所有用户的所有仓库都生效。配置文件通常位于 &#x2F;etc&#x2F;gitconfig（Linux 或 macOS）。</p></li><li><p>全局级配置：对当前用户的所有仓库生效。配置文件位于用户主目录下的 .gitconfig 文件（Linux 或 macOS）或 C:\Users\用户名.gitconfig（Windows）。</p></li><li><p>仓库级配置：仅对当前仓库生效。配置文件位于当前仓库的 .git&#x2F;config 文件中。</p></li><li><p>基本配置命令<br>使用 git config 命令来进行配置，通过不同的选项指定配置的级别。</p></li><li><p>系统级配置：使用 –system 选项。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --system user.name <span class="string">&quot;SystemUserName&quot;</span></span><br><span class="line">git config --system user.email <span class="string">&quot;systemuser@example.com&quot;</span> </span><br></pre></td></tr></table></figure></li><li><p>全局级配置：使用 –global 选项。这是最常用的配置级别，为当前用户的所有仓库设置默认信息。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>仓库级配置：使用 –local 选项（可省略）。当不指定选项时，默认就是对当前仓库进行配置。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">&quot;RepoUserName&quot;</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">&quot;repouser@example.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>查看所有配置信息：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></li><li><p>查看特定配置项的值：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure></li><li><p>删除配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name</span><br></pre></td></tr></table></figure></li></ul><h4 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h4><p>仓库初始化</p><ul><li>git init<ul><li>功能：在当前目录下创建一个新的 Git 仓库。执行此命令后，会在该目录下生成一个隐藏的 .git 文件夹，用于存储版本控制的相关信息。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my_project</span><br><span class="line"><span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>仓库克隆</p><ul><li>git clone<ul><li>功能：从远程仓库复制一份到本地。可以通过指定远程仓库的 URL 来完成克隆操作。</li><li>示例：克隆一个名为 <code>example-repo</code> 的 GitHub 仓库到本地。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/example-repo.git</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>文件操作</p><ul><li>git add<ul><li>功能：将文件添加到暂存区。暂存区是提交之前的一个中间区域，可以选择部分修改的文件进行提交。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file.txt         <span class="comment"># 添加单个文件</span></span><br><span class="line">git add .                <span class="comment"># 添加当前目录下的所有文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>git commit<ul><li>功能：将暂存区的文件提交到本地仓库。需要使用 <code>-m</code> 参数添加提交信息，描述本次提交的内容。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Add a new feature&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>git rm<ul><li>功能：从 Git 仓库中删除文件，并将删除操作记录到暂存区。</li><li>示例  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file.txt</span><br></pre></td></tr></table></figure></li></ul></li><li>git mv<ul><li>功能：移动或重命名文件，并将操作记录到暂存区。</li><li>示例：将 old_name.txt 重命名为 new_name.txt。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> old_name.txt new_name.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>查看状态与历史</p><ul><li>git status<ul><li>功能：查看当前仓库的状态，包括哪些文件被修改、哪些文件在暂存区、哪些文件未被跟踪等信息。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li></ul></li><li>git log<ul><li>功能：查看提交历史记录，显示每个提交的哈希值、作者、日期和提交信息。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul></li><li>常用选项：<ul><li>–oneline：以简洁的一行格式显示提交信息。</li><li>–graph：以图形化的方式显示分支合并历史。<br>分支管理</li></ul></li><li>git branch<ul><li>功能：用于列出、创建或删除分支。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch               <span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch new_branch    <span class="comment"># 创建一个新的分支</span></span><br><span class="line">git branch -d new_branch <span class="comment"># 删除指定分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>git checkout<ul><li>功能：切换分支或恢复工作区文件。</li><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout new_branch  <span class="comment"># 切换到指定分支</span></span><br><span class="line">git checkout -b new_branch <span class="comment"># 创建并切换到新分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>git merge<ul><li>功能：将一个分支的修改合并到当前分支。</li><li>示例：将 feature 分支合并到 master 分支  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>远程协作</p><ul><li>git remote<ul><li>功能：管理远程仓库的别名和 URL。</li><li>示例：将 feature 分支合并到 master 分支  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v            <span class="comment"># 查看远程仓库的别名和URL</span></span><br><span class="line">git remote add origin https://github.com/username/example-repo.git <span class="comment"># 添加远程仓库</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>git push<ul><li>功能：将本地仓库的提交推送到远程仓库。</li><li>示例：将本地的 master 分支推送到远程仓库的 master 分支。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>git pull<ul><li>功能：从远程仓库拉取最新的代码并合并到本地仓库。</li><li>示例：从远程仓库的 master 分支拉取代码并合并到本地的 master 分支。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>标签<br>git tag</p><ul><li>功能：列出标签<ul><li>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="comment">#列出所有标签</span></span><br><span class="line"></span><br><span class="line">git tal -l <span class="string">&quot;v1&quot;</span> <span class="comment">#列出匹配标签</span></span><br><span class="line">git show &lt;标签名称&gt; 显示特定标签细节</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>git tag &lt;标签名称&gt;</p><ul><li>功能：创建轻量标签</li></ul><p>git tag -a &lt;标签名称&gt; -m &lt;备注信息&gt;</p><ul><li>功能：注释标签</li></ul><p>git tag -a &lt;标签名称&gt; -m &lt;备注信息&gt; <commitID></p><ul><li>功能：后期打标签</li></ul><p>git tag -d&lt;标签名称&gt;</p><ul><li>功能：删除标签</li></ul><p>git push origin -d tag&lt;标签1名称&gt; &lt;标签n名称&gt;</p><ul><li>功能：删除远程仓库标签</li></ul><p>git push origin &lt;标签1名称&gt; &lt;标签n名称&gt;</p><ul><li>功能：推送标签到远程仓库 一个或多个<br>git push origin –tags</li><li>功能：推送全部标签到远程仓库<blockquote><p>git push 推送代码时， 标签不会被推送，需要单独 push 标签<br>origin 为远程仓库的别名（自己随便起）</p></blockquote></li></ul><p>.gitignore文件<br>忽略不需要版本控制的文件</p><ul><li>每个配置单独占一行</li><li>每行内容可以是：文件&#x2F;目录的名称、路径 或 他们的匹配模式。</li></ul><p>从版本库中恢复文件<br>    1. 已删除(或者修改)，未add<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;文件路径&gt; #如： git checkout a.txt</span><br></pre></td></tr></table></figure><br>    2. 已删除(或者修改)，已经add，未commit<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commitID&gt;  &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><br>    3. 已删除(或者修改)，已经commit（恢复到任意版本和上面指令一样）<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;commitID&gt;  &lt;文件路径&gt;</span><br></pre></td></tr></table></figure></p><p>提交冲突与解决办法<br>产生原因：提交者的版本库 &lt; 远程库</p><ol><li>实现远程仓库与本地仓库同步<ul><li>git pull  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull </span><br></pre></td></tr></table></figure></li></ul></li><li>解决冲突<ul><li>能自动解决的冲突  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><blockquote><p>总结：无需过多操作 git push前执行git pull即可</p></blockquote></li><li>手动解决冲突 然后提交  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网盘搭建图床(AList+网盘)</title>
      <link href="//blogs/%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A-AList-%E7%BD%91%E7%9B%98.html"/>
      <url>//blogs/%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A-AList-%E7%BD%91%E7%9B%98.html</url>
      
        <content type="html"><![CDATA[<h4 id="安装AList"><a href="#安装AList" class="headerlink" title="安装AList"></a>安装AList</h4><ul><li>AList 官方文档：<a href="https://alist.nn.ci/">https://alist.nn.ci</a></li><li>AList github地址：<a href="https://github.com/AlistGo/alist">https://github.com/AlistGo/alist</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 解压下载的文件，得到可执行文件：</span><br><span class="line">tar -zxvf alist-xxxx.tar.gz</span><br><span class="line"># 授予程序执行权限：</span><br><span class="line">chmod +x alist</span><br><span class="line"># 运行程序</span><br><span class="line">./alist server</span><br><span class="line"></span><br><span class="line"># 获得管理员信息 以下两个不同版本，新版本也有随机生成和手动设置</span><br><span class="line"># 低于v3.25.0版本</span><br><span class="line">./alist admin</span><br><span class="line"></span><br><span class="line"># 高于v3.25.0版本</span><br><span class="line"># 随机生成一个密码</span><br><span class="line">./alist admin random</span><br><span class="line"># 手动设置一个密码 `NEW_PASSWORD`是指你需要设置的密码</span><br><span class="line">./alist admin set NEW_PASSWORD</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="网盘挂载到AList（WebDAV服务）"><a href="#网盘挂载到AList（WebDAV服务）" class="headerlink" title="网盘挂载到AList（WebDAV服务）"></a>网盘挂载到AList（WebDAV服务）</h4><ul><li>详见文档 <a href="https://alist.nn.ci/zh/guide/drivers/">https://alist.nn.ci/zh/guide/drivers/</a></li></ul><blockquote><p>默认服务在5244端口开启</p></blockquote><h3 id="使用Nginx反向代理"><a href="#使用Nginx反向代理" class="headerlink" title="使用Nginx反向代理"></a>使用Nginx反向代理</h3><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    #listen 443 ssl; </span><br><span class="line">    # 转发 Alist WebDAV 图片访问请求</span><br><span class="line">    location /img &#123;</span><br><span class="line">        proxy_pass http://localhost:[Alist服务端口]/d/[imagePath];</span><br><span class="line">        proxy_read_timeout 600s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Host $host:$server_port;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果使用Termux搭建服务 可以使用<code>pkg install AList</code> 安装AList<br>如果不需要签名 可以在AList管理页面中设置 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> -图床 -网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="//blogs/hello-world.html"/>
      <url>//blogs/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ipv6可能会需要的小知识</title>
      <link href="//blogs/ipv6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%9C%80%E8%A6%81%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86.html"/>
      <url>//blogs/ipv6%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%9C%80%E8%A6%81%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<h3 id="ipv6设置"><a href="#ipv6设置" class="headerlink" title="ipv6设置"></a>ipv6设置</h3><ul><li>确保运行商已经接入ipv6</li><li>ipv6可能需要在(光猫、路由器)设置，光猫和路由器因品牌不一，具体设置需要自行百度 </li><li>电脑需开启ipv6<ul><li>控制面板&gt;网络和Internet&gt;网络连接&gt;右击正在使用的网卡&gt;属性&gt;选中Internet协议版本6(TCP&#x2F;IPv6)&gt;确定</li></ul></li></ul><p><strong><a href="http://test-ipv6.com/">点击我查看是否可以使用ipv6</a></strong></p><h3 id="ipv6小知识"><a href="#ipv6小知识" class="headerlink" title="ipv6小知识"></a>ipv6小知识</h3><ol><li>可能需要设置防火墙  (光猫、路由器、服务器)   </li><li>使用ipv6进行http请求的格式http:&#x2F;&#x2F;[ipv6地址]:端口   </li><li>运行商可能会屏蔽一些端口 例如80、8080，使用其他端口即可</li><li>有的游戏可以使用ipv6进行联机，如MC</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ipv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建git服务器</title>
      <link href="//blogs/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
      <url>//blogs/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h3><ol><li><p>确保已经安装好了git</p></li><li><p>初始化git仓库</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#进入存放仓库目录</span><br><span class="line">sudo git init --bare 仓库.git</span><br></pre></td></tr></table></figure></li><li><p>生成ssh公钥</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p> 公钥保存位置 </p><blockquote><p>可以使用记事本打开 linux下可以使用cat命令查看<br>windows下： C:&#x2F;用户&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub<br>linux下： &#x2F;用户&#x2F;.ssh&#x2F;id_rsa.pub<br>将公钥复制到.ssh&#x2F;authorized_keys文件内</p></blockquote></li><li><p>克隆远程仓库</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip:/仓库目录/仓库.git</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipv6进行ssh连接</title>
      <link href="//blogs/ipv6%E8%BF%9B%E8%A1%8Cssh%E8%BF%9E%E6%8E%A5.html"/>
      <url>//blogs/ipv6%E8%BF%9B%E8%A1%8Cssh%E8%BF%9E%E6%8E%A5.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>查看是否可以使用ipv6</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> #查看是否有ipv6地址</span><br></pre></td></tr></table></figure></li><li><p>进行ipv6测试<br><a href="http://ch.test-ipv6.com/index.html.zh_CN">点我查看是否可以使用ipv6</a></p></li><li><p>修改sshd配置</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddressFamily inet6</span><br><span class="line">ListenAddress ::</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重启sshd服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ssh </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ipv6 </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机作为服务器(Termux)</title>
      <link href="//blogs/%E6%89%8B%E6%9C%BA%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8-Termux.html"/>
      <url>//blogs/%E6%89%8B%E6%9C%BA%E4%BD%9C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8-Termux.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Termux"><a href="#安装-Termux" class="headerlink" title="安装 Termux"></a>安装 Termux</h2><h3 id="下载方式"><a href="#下载方式" class="headerlink" title="下载方式"></a>下载方式</h3><ul><li><a href="https://f-droid.org/packages/com.termux/">f-droid</a></li><li><a href="https://termux.dev/en/">官网</a></li><li><a href="https://github.com/termux/termux-app#github">gitHub</a></li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ol><li>获取手机存储权限 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termux-setup-storage </span><br></pre></td></tr></table></figure></li><li>换源 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termux-change-repo</span><br></pre></td></tr></table></figure></li><li>更新 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg update</span><br></pre></td></tr></table></figure></li><li>安装vm <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install  vim</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><ol><li>安装openssh <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install openssh </span><br></pre></td></tr></table></figure></li><li>设置密码并开启服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br><span class="line"></span><br><span class="line">sshd</span><br></pre></td></tr></table></figure></li><li>使用远程连接工具连接<blockquote><p>输入ip地址和端口号进行连接  Termuxs的ssh端口号默认为8022</p></blockquote></li></ol><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><ol><li>安装及配置 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pkg install nginx #安装</span><br><span class="line"># 配置nginx</span><br><span class="line"># pkg file 包名 可查询包的相关文件</span><br><span class="line">pkg file nginx </span><br><span class="line">#打开nginx配置文件进行配置即可</span><br><span class="line">vim usr/etc/nginx/nginx.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>启动服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx  #启动服务</span><br><span class="line">nginx -s reload  #重启服务</span><br><span class="line">nginx -s stop #停止服务</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnlp #查看端口使用情况</span><br><span class="line">pkill 进程名 #杀死进程</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Termux-自动执行"><a href="#Termux-自动执行" class="headerlink" title="Termux 自动执行"></a>Termux 自动执行</h3><ul><li>Termux开启后会自动执行<code>home/.bashrc</code>文件的内容</li><li>可以将 <code>nginx</code> <code>sshd</code> 等服务自启</li></ul><h3 id="Termux-使用crontab定时任务"><a href="#Termux-使用crontab定时任务" class="headerlink" title="Termux 使用crontab定时任务"></a>Termux 使用crontab定时任务</h3><ol><li><p>安装</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install cronie</span><br></pre></td></tr></table></figure></li><li><p>创建定时任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></li><li><p>编辑器内容说明</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br><span class="line"></span><br><span class="line">第一个* 取值范围0-59 表示分钟</span><br><span class="line">第二个* 取值范围0-23 表示小时</span><br><span class="line">第三个* 取值范围1-31 表示几号</span><br><span class="line">第四个* 取值范围1-12 表示月份</span><br><span class="line">第五个* 取值范围0-7  表示星期</span><br><span class="line">command 表示需要执行的命令</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>查看定时任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>启动服务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crond      </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="//blogs/docker.html"/>
      <url>//blogs/docker.html</url>
      
        <content type="html"><![CDATA[<h3 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h3><h4 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h4><ol><li><p>安装 wsl2</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br><span class="line">wsl --<span class="built_in">set</span>-version &lt;distro name&gt; <span class="number">2</span> </span><br></pre></td></tr></table></figure></li><li><p>设置Linux 用户名和密码</p><blockquote><p>如果 win10&#x2F;win11下启动wsl&#x2F;wsl2出现“占位程序接收到错误数据“启  动  失败的解决办法 管理员身份启动cmd&#x2F;   powershell , 运行 netsh  winsock reset</p></blockquote></li><li><p>安装docker desktop<br><a href="https://www.docker.com/">官网下载</a>安装即可</p></li><li><p>打开docker desktop </p><ul><li>setting&gt;General&gt;启用基于WSL2的引擎</li><li>setting&gt;Resources&gt;WSL integration&gt;启用已安装的WLS2发行版</li></ul></li><li><p>打开已安装的 WSL发行版 输入<code>docker --version</code>显示版本号，输入<code>docker run hello-world</code> 运行测试镜像</p></li></ol><h3 id="docker-换源"><a href="#docker-换源" class="headerlink" title="docker 换源"></a>docker 换源</h3><ul><li>linux：  修改<code>/etc/docker/daemon.json</code>文件，添加</li><li>windows：Docker Desktop &gt; 设置 &gt; Docker Engine 添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;: [</span><br><span class="line">   &quot;https://registry.docker-cn.com&quot;, # docker中国区镜像</span><br><span class="line">   &quot;https://docker.mirrors.ustc.edu.cn/&quot;, # 科技大学</span><br><span class="line">   &quot;https://hub-mirror.c.163.com/&quot;  # 网易</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h3><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version # 显示docker 版本信息</span><br><span class="line">docker info   # 显示docker系统信息</span><br><span class="line">docker 命令 --help # 命令帮助</span><br></pre></td></tr></table></figure><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><ol><li><p><strong>查看本地镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker images # 查看本地镜像  </span><br><span class="line">   Options:</span><br><span class="line">   -a, --all             列出全部镜像</span><br><span class="line">   -f, --filter filter   过滤</span><br><span class="line">   -q, --quiet           只显示镜像ID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      REPOSITORY    TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">      hello-world   latest    9c7a54a9a43c   10 days ago   13.3kB</span><br><span class="line"></span><br><span class="line">      # REPOSITORY 镜像仓库源</span><br><span class="line">      # TAG        镜像标签</span><br><span class="line">      # IMAGE ID   镜像ID</span><br><span class="line">      # CREATED    镜像创建时间</span><br><span class="line">      # SIZE       镜像大小</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>搜索镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称  # 搜索镜像</span><br><span class="line">   Options:</span><br><span class="line">   -- filter             # 过滤 -- filter = STARS = 2000</span><br></pre></td></tr></table></figure></li><li><p><strong>拉取镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称:[tag] # 拉取镜像 默认最新版本</span><br></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f 镜像名称或镜像ID # 删除镜像 </span><br><span class="line">docker rmi -f 镜像名称或镜像ID 镜像名称或镜像ID ... # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像 </span><br></pre></td></tr></table></figure></li></ol><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><ol><li><p><strong>启动镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run [Options] 镜像 # 启动镜像</span><br><span class="line">   Options:</span><br><span class="line">    --name=&quot;Name&quot;        #容器名字 用来区分容器</span><br><span class="line">    -d                   #后台方式运行</span><br><span class="line">    -it                  #使用交互方式运行，进入容器查看内容</span><br><span class="line">          exit #退出容器</span><br><span class="line">    -p                   #指定容器的端口 </span><br><span class="line">      -p 主机端口:容器端口 #主机端口映射到容器端口</span><br><span class="line">      -p ip:主机端口:容器端口</span><br><span class="line">    -P                   #随机指定端口</span><br></pre></td></tr></table></figure></li><li><p><strong>列出已启动的容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps #列出已启动的容器</span><br><span class="line">   Options:</span><br><span class="line">   -a                   #列出已启动的容器和历史运行过得容器</span><br><span class="line">   -n=个数              #显示最近创建的容器</span><br><span class="line">   -q                   #只显示容器编号 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>退出容器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit                    #停止容器并退出容器</span><br><span class="line">Ctrl+P+Q                #容器不停止退出</span><br></pre></td></tr></table></figure></li><li><p><strong>删除容器</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器ID                   #删除指定容器 不能删除正在运行的容器</span><br><span class="line">docker rm -f 容器ID               #强制删除指定容器</span><br><span class="line">docker rm -f $(docker ps -aq)     #删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm   # 删除所有容器 </span><br></pre></td></tr></table></figure></li><li><p><strong>启动和停止容器</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID              #启动容器</span><br><span class="line">docker restart 容器ID            #重启容器</span><br><span class="line">docker stop 容器ID               #停止当前正在运行的容器</span><br><span class="line">docker kill 容器ID               #强制停止容器</span><br></pre></td></tr></table></figure></li></ol><h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><h4 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 个数 容器ID  #查看指定</span><br><span class="line"> Options:</span><br><span class="line"> -tf                    #显示日志时间戳</span><br><span class="line"> --tail 个数            #显示日志的条数</span><br></pre></td></tr></table></figure><h4 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><h4 id="查看容器元数据"><a href="#查看容器元数据" class="headerlink" title="查看容器元数据"></a>查看容器元数据</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line">docker exec -it 容器ID  /bin/bash</span><br><span class="line">方式二</span><br><span class="line">docker attach 容器ID </span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line">docker exec   #进入容器开启一个新的命令行</span><br><span class="line">docker attach  #进入容器当前正在执行的命令行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="容器拷贝文件到主机"><a href="#容器拷贝文件到主机" class="headerlink" title="容器拷贝文件到主机"></a>容器拷贝文件到主机</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径  主机路径</span><br></pre></td></tr></table></figure><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>将主机目录和容器目录进行映射 双向绑定同步 数据持久化</p><ol><li>指定路径挂载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /主机目录:容器目录 镜像 /bin/bash</span><br></pre></td></tr></table></figure></li><li>具名挂载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 目录名字:容器目录 镜像 /bin/bash</span><br></pre></td></tr></table></figure></li><li>匿名挂载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 容器目录 镜像 /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p> 可以进行多次挂载 -v 可以在一条指令中使用多次<br> -v 容器路径:ro&#x2F;rw 改变容器读写权限 ro代表read-only只读 rw表示read-write可读可写</p></blockquote></li></ol><p>具名挂载和匿名挂载可是使用<code>docker volume ls</code> 查看挂载卷 使用<code>docker volume inspect 挂载卷</code> 可以查看挂载卷具体信息</p><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>通过容器创建镜像</p><ul><li><h4 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;作者&quot; -m &quot;描述&quot; 容器id  镜像名字:版本</span><br></pre></td></tr></table></figure></li><li><h4 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h4><p>通过脚本来构建docker镜像</p></li></ul><ol><li>docker文件的编写(docker指令)</li></ol><ul><li>关键字都是大写字母</li><li>从上向下执行</li><li>#表示注 释</li><li>每个指令都会创建提交一个新的层   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">docker build -f 文件路径 -t 名字:标签 .</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>容器间数据共享 配置信息传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -volumes-from 父容器目录 镜像 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建博客</title>
      <link href="//blogs/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html"/>
      <url>//blogs/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ol><li>安装node.js</li><li>安装git</li><li>注册github</li></ol><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><ol><li><p>新建文件夹</p><blockquote><p>在本地创建博客文件夹</p></blockquote></li><li><p>安装hexo</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure></li><li><p>执行hexo命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init <span class="comment"># 初始化项目</span></span><br><span class="line">npm install <span class="comment"># 安装npm依赖包</span></span><br><span class="line">hexo generate <span class="comment"># 生成静态页面 可以简写为 hexo g</span></span><br><span class="line">hexo server <span class="comment"># 生成本地服务 可以简写为 hexo s</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="部署博客到github"><a href="#部署博客到github" class="headerlink" title="部署博客到github"></a>部署博客到github</h2><ol><li><p>新建一个仓库 </p><blockquote><p>仓库路径为：guthub名字.github.io</p></blockquote></li><li><p>将博客项目上传至github</p><p> 安装hexo的上传插件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>打开项目文件夹中的<code>_config.yml</code>文件</p><p> 将deploy下修改为：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 你的远程仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>将项目推送到远程仓库</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy # 可以简写为 hexo d</span><br></pre></td></tr></table></figure></li><li><p>使用你的用户名+github.io访问博客</p></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ol><li><p>下载主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址 themes/主题名字</span><br></pre></td></tr></table></figure></li><li><p>配置主题</p><blockquote><p>打开项目文件夹下的<code>_config.yml</code>文件中的<code>theme:主题名字</code></p></blockquote></li><li><p>更新</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo s </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><ol><li><p>新建博客</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;博客名字&quot;</span><br></pre></td></tr></table></figure><p> 会在项目source文件夹下创建一个<code>.md</code>文件 可以用markdown语法编写博客</p></li><li><p>生成网页</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s # 可以在本地预览 也可以直接执行hexo d 上传到远程仓库</span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure></li></ol><h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><ul><li>比如新建标签页  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tages&quot;</span><br></pre></td></tr></table></figure></li><li>打开 &#x2F;source&#x2F;tages&#x2F;index.md，设置其类型 type 值为“tages”  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: tages</span><br><span class="line">data: </span><br><span class="line">typee: tages</span><br></pre></td></tr></table></figure></li></ul><h2 id="markdown文件header"><a href="#markdown文件header" class="headerlink" title="markdown文件header"></a>markdown文件header</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2023-04-01</span><br><span class="line">tags:</span><br><span class="line">- Tag1</span><br><span class="line">- Tag2</span><br><span class="line">categories:</span><br><span class="line">- Category1</span><br><span class="line">- Category2</span><br><span class="line">---</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
